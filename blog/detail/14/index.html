<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>React 常用 Hook&amp;Hook 闭包陷阱</title><link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico"><link rel="sitemap" href="/sitemap-index.xml"><title>React 常用 Hook&Hook 闭包陷阱</title><link rel="canonical" href="https://wty9sky.github.io/blog/detail/14/"><meta name="description" content="React 常用 Hook以及Hook 闭包陷阱"><meta name="robots" content="index, follow"><meta property="og:title" content="React 常用 Hook&#38;Hook 闭包陷阱"><meta property="og:type" content="article"><meta property="og:image" content="/og.svg"><meta property="og:url" content="https://wty9sky.github.io/blog/detail/14/"><meta property="og:locale" content="zh_CN"><meta property="og:locale:alternate" content="zh_TW"><meta property="og:locale:alternate" content="en_US"><meta property="og:site_name" content="9Sky 九天"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/avatar.png"><meta name="generator" content="Astro v4.16.7"><meta name="keywords" content="详情"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.CkC6PiIh.css">
<link rel="stylesheet" href="/_astro/about.D3zQv4Ly.css"><script type="module" src="/_astro/hoisted.HO6_Fzad.js"></script></head> <body> <header class="header"> <h5 class="header__heading"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
React 常用 Hook&amp;Hook 闭包陷阱 </span> </h5> </header> <div id="navbar-sentinal"></div> <nav class="navbar" id="navbar-wrapper"> <div class="navbar__content"> <h5 class="navbar__path"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
React 常用 Hook&amp;Hook 闭包陷阱 </span> </h5> <div class="navbar__menu"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("#navbar-sentinal");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersectin && e[0].boundingClientRect.top <= 0) {
        headerEl.classList.add("navbar--sticked");
      } else {
        headerEl.classList.remove("navbar--sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>  <main class="page"> <section class="page__section page__section--at-top"> <!-- {
        article.cover && (
          <a href={article.cover} data-fancybox data-caption={article.title}>
            <img
              src={article.cover}
              alt={article.title}
              title={article.title}
              class="page__cover mb-8"
            />
          </a>
        )
      } --> <h1 class="page__heading">React 常用 Hook&amp;Hook 闭包陷阱</h1> <p class="page__meta"> <i class="ri-calendar-line"></i> <span>2023 年 8 月 12 日 10:01</span> </p> <hr class="page__divide"> <article class="content"> <h2><a id="文章目录" class="content__heading-anchor"></a>文章目录</h2>
<ul>
<li><a href="#%E7%BB%84%E4%BB%B6%E5%B8%B8%E7%94%A8-hookhook-%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1">组件常用 Hook&amp;Hook 闭包陷阱</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8-hook">常用 Hook</a>
<ul>
<li><a href="#usestate">useState</a></li>
<li><a href="#useeffect">useEffect</a></li>
<li><a href="#uselayouteffect">useLayoutEffect</a></li>
<li><a href="#usereducer">useReducer</a></li>
<li><a href="#usereducer--immer">useReducer + immer</a></li>
<li><a href="#useref">useRef</a></li>
<li><a href="#forwardref--useimperativehandle">forwardRef + useImperativeHandle</a></li>
<li><a href="#usecontext">useContext</a></li>
<li><a href="#memo--usememo--usecallback">memo + useMemo + useCallback</a></li>
<li><a href="#react19-%E6%96%B0%E5%A2%9E-hook">React19 新增 Hook</a></li>
</ul></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#hook-%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1">Hook 闭包陷阱</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1">什么是闭包陷阱</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">解决办法</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%A7%8D">第一种</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D">第二种</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%A7%8D-useref">第三种 useRef</a></li>
</ul></li>
<li><a href="#%E6%89%A9%E5%B1%95-%E5%B0%81%E8%A3%85%E5%AE%9A%E6%97%B6%E5%99%A8">扩展 封装定时器</a></li>
</ul></li>
</ul></li>
</ul>
<h1><a id="组件常用-hookhook-闭包陷阱" class="content__heading-anchor"></a>组件常用 Hook&amp;Hook 闭包陷阱</h1>
<p>React 组件支持 class、function 两种形式，但现在绝大多数情况都是 function 组件。</p>
<p>官方文档也已经把 class 组件的语法划到了 legacy（遗产）部分，并建议开发者使用 function 组件。</p>
<h2><a id="常用-hook" class="content__heading-anchor"></a>常用 Hook</h2>
<h3><a id="usestate" class="content__heading-anchor"></a>useState</h3>
<p>从一种数据变成另一种数据，这种就是状态（state）了。<br>
也就是说，状态是变化的数据,组件的核心就是状态。<br>
组件内的状态是 useState 创建的，整个应用还可以加一个全局状态管理的库来管理 state。<br>
state 是基础，也是前端应用的核心。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> num1 = <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;
  <span class="hljs-keyword">const</span> num2 = <span class="hljs-number">2</span> + <span class="hljs-number">3</span>;
  <span class="hljs-keyword">return</span> num1 + num2;
});
</code></pre>
<p>useState 返回一个数组，包含 xxx 和 setXxx，一般用解构语法获取。</p>
<p>这个 useState 也有两种参数：</p>
<ul>
<li>可以直接传新的值</li>
<li>或者传一个函数，返回新的值，这个函数的参数是上一次的 state。</li>
</ul>
<h3><a id="useeffect" class="content__heading-anchor"></a>useEffect</h3>
<p>effect 被翻译为副作用。</p>
<p>之前的函数组件是纯函数，传入 props，返回对应的结果，再次调用，传入 props，依然返回同样的结果。</p>
<p>但现在有了 effect 之后，每次执行函数，额外执行了一些逻辑，这些逻辑不就是副作用么？</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">queryData</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> data =
    (<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>()) &lt;
    number &gt;
    (<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-title function_">resolve</span>(<span class="hljs-number">666</span>);
      }, <span class="hljs-number">2000</span>);
    });
  <span class="hljs-keyword">return</span> data;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">queryData</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
      <span class="hljs-title function_">setNum</span>(data);
    });
  }, []);

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum((prevNum) =&gt; prevNum + 1)}&gt;{num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<blockquote>
<p>注：想用 async await 语法需要单独写一个函数，因为 useEffect 参数的那个函数不支持 async。</p>
</blockquote>
<p>请求数据、定时器等这些异步逻辑，都会放在 useEffect 里。</p>
<p>第二个参数：这个数组叫做依赖数组，react 是根据它有没有变来决定是否执行 effect 函数的，如果没传则每次都执行。</p>
<p>如果数组中有个变化的值，那就会触发重新执行 effect 函数。</p>
<p>这个数组我们一般写依赖的 state，这样在 state 变了之后就会触发重新执行了。</p>
<p>问题：在 useEffect 跑了一个定时器，依赖变了之后，再次执行 useEffect，如何清理上一个定时器？</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;effect&quot;</span>);
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num);
    }, <span class="hljs-number">1000</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;clean up&quot;</span>);
      <span class="hljs-built_in">clearInterval</span>(timer);
    };
  }, [num]);

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum((prevNum) =&gt; prevNum + 1)}&gt;{num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>当 deps 数组变了，重新执行 effect 之前，会先执行清理函数，打印了 clean up；组件销毁时也会调用 cleanup 函数来进行清理。</p>
<h3><a id="uselayouteffect" class="content__heading-anchor"></a>useLayoutEffect</h3>
<p>和 useEffect 类似的还有一个 useLayoutEffect。</p>
<pre><code class="language-javascript"><span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;effect&quot;</span>);
}, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
</code></pre>
<p>大多数情况下，useEffect 和 useLayoutEffect 功能一样。</p>
<p>区别在于：useEffect 默认是异步执行的，而 useLayoutEffect 是同步执行的。</p>
<p>由于 js 执行和渲染是阻塞的，useEffect 的 effect 函数会在操作 dom 之后异步执行，这些逻辑会以单独的宏任务或者微任务的形式存在，然后进入 Event Loop 调度执行。</p>
<p>所以异步执行的 effect 逻辑就有两种可能：</p>
<ul>
<li>有可能在下次渲染之前，就能执行完这个 effect。</li>
<li>也有可能下次渲染前，没时间执行这个 effect，所以就在渲染之后执行了。</li>
</ul>
<p>这样就导致有的时候页面会出现闪动，因为第一次渲染的时候的 state 是之前的值，渲染完之后执行 effect 改了 state，在此渲染就是新的值了。</p>
<p>如果不想闪动那一下，就用 useLayoutEffect。</p>
<p>与 useEffect 的区别：</p>
<ul>
<li>useLayoutEffect 的 effect 执行是同步的。这样浏览器会等 effect 逻辑执行完再渲染。</li>
<li>好处是不会闪动。</li>
<li>坏处是如果 effect 逻辑执行时间太长，会阻塞渲染。</li>
</ul>
<p>总结：</p>
<ul>
<li>大多数情况下，用 useEffect 能避免因为 effect 逻辑执行时间长导致页面卡顿（掉帧）。</li>
<li>但如果闪动的问题比较严重，可以用 useLayoutEffect，但要注意 effect 逻辑执行时间长度，避免卡顿。</li>
</ul>
<h3><a id="usereducer" class="content__heading-anchor"></a>useReducer</h3>
<ul>
<li><p>useReducer 的类型参数传入 Reducer&lt;数据的类型，action 的类型&gt;</p></li>
<li><p>然后第一个参数是 reducer，第二个参数是初始数据。</p></li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Reducer</span>, useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

interface <span class="hljs-title class_">Data</span> {
    <span class="hljs-attr">result</span>: number;
}

interface <span class="hljs-title class_">Action</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;add&#x27;</span> | <span class="hljs-string">&#x27;minus&#x27;</span>,
    <span class="hljs-attr">num</span>: number
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state: Data, action: Action</span>) {

    <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;add&#x27;</span>:
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">result</span>: state.<span class="hljs-property">result</span> + action.<span class="hljs-property">num</span>
            }
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;minus&#x27;</span>:
            <span class="hljs-keyword">return</span> {
                <span class="hljs-attr">result</span>: state.<span class="hljs-property">result</span> - action.<span class="hljs-property">num</span>
            }
    }
    <span class="hljs-keyword">return</span> state;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [res, dispatch] = useReducer&lt;<span class="hljs-title class_">Reducer</span>&lt;<span class="hljs-title class_">Data</span>, <span class="hljs-title class_">Action</span>&gt;&gt;(reducer, { <span class="hljs-attr">result</span>: <span class="hljs-number">0</span>});

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: &#x27;add&#x27;, num: 2 })}&gt;加<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: &#x27;minus&#x27;, num: 1 })}&gt;减<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{res.result}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>和 useState 的区别：</p>
<ul>
<li>用 useState 需要在每个地方都写一遍这个逻辑</li>
<li>用 useReducer 则是把它封装到 reducer 里，通过 action 触发</li>
<li>当修改 state 的逻辑比较复杂，用 useReducer</li>
</ul>
<h3><a id="usereducer--immer" class="content__heading-anchor"></a>useReducer + immer</h3>
<p>使用 reducer 时候，如果直接修改原始的 state 返回，无法触发 DOM 重新渲染。</p>
<p>需要重新返回对象，如果对象结构很复杂，每次都创建一个新的对象会比较繁琐，而且性能也不好。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Reducer</span>, useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

interface <span class="hljs-title class_">Data</span> {
    <span class="hljs-attr">a</span>: {
        <span class="hljs-attr">c</span>: {
            <span class="hljs-attr">e</span>: number,
            <span class="hljs-attr">f</span>: number
        },
        <span class="hljs-attr">d</span>: number
    },
    <span class="hljs-attr">b</span>: number
}

interface <span class="hljs-title class_">Action</span> {
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;add&#x27;</span>,
    <span class="hljs-attr">num</span>: number
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state: Data, action: Action</span>) {

    <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;add&#x27;</span>:
            <span class="hljs-keyword">return</span> {
                ...state,
                <span class="hljs-attr">a</span>: {
                    ...state.<span class="hljs-property">a</span>,
                    <span class="hljs-attr">c</span>: {
                        ...state.<span class="hljs-property">a</span>.<span class="hljs-property">c</span>,
                        <span class="hljs-attr">e</span>: state.<span class="hljs-property">a</span>.<span class="hljs-property">c</span>.<span class="hljs-property">e</span> + action.<span class="hljs-property">num</span>,
                    },
                },
            }
    }
    <span class="hljs-keyword">return</span> state;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [res, dispatch] = useReducer&lt;<span class="hljs-title class_">Reducer</span>&lt;<span class="hljs-title class_">Data</span>, <span class="hljs-title class_">Action</span>&gt;, string&gt;(reducer, <span class="hljs-string">&#x27;zero&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">param</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">a</span>: {
            <span class="hljs-attr">c</span>: {
                <span class="hljs-attr">e</span>: <span class="hljs-number">0</span>,
                <span class="hljs-attr">f</span>: <span class="hljs-number">0</span>
            },
            <span class="hljs-attr">d</span>: <span class="hljs-number">0</span>
        },
        <span class="hljs-attr">b</span>: <span class="hljs-number">0</span>
    }
  });

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: &#x27;add&#x27;, num: 2 })}&gt;加<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{JSON.stringify(res)}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;

</code></pre>
<p>需要重复写对象代码，造成代码冗余</p>
<p>解决方案：复杂对象的修改就要用 immutable 相关的库，比如 immer</p>
<pre><code class="language-bash">npm install --save immer
</code></pre>
<pre><code class="language-javascript"><span class="hljs-keyword">return</span> <span class="hljs-title function_">produce</span>(state, <span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> {
  state.<span class="hljs-property">a</span>.<span class="hljs-property">c</span>.<span class="hljs-property">e</span> += action.<span class="hljs-property">num</span>;
});
</code></pre>
<p>immer 是依赖 Proxy 实现的，会监听函数里对属性的修改，然后创建一个新对象</p>
<p>reducer 需要返回一个新的对象，才会触发渲染，而 useState 也是</p>
<pre><code class="language-javascript"><span class="hljs-title function_">setObj</span>(
  <span class="hljs-title function_">produce</span>(obj, <span class="hljs-function">(<span class="hljs-params">obj</span>) =&gt;</span> {
    obj.<span class="hljs-property">a</span>.<span class="hljs-property">c</span>.<span class="hljs-property">e</span>++;
  })
);
</code></pre>
<p>在 react 里，只要涉及到 state 的修改，就必须返回新的对象，不管是 useState 还是 useReducer</p>
<h3><a id="useref" class="content__heading-anchor"></a>useRef</h3>
<p>useRef 是一个 React Hook，它能帮助引用一个不需要渲染的值。<br>
useRef 保存 dom 引用或者其他内容，通过 xxRef.current 来取，改变它的内容不会触发重新渲染。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(initialValue);
</code></pre>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useEffect, useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> inputRef = useRef &lt; <span class="hljs-title class_">HTMLInputElement</span> &gt; <span class="hljs-literal">null</span>;

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    inputRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">focus</span>();
  });

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>如果需要触发渲染，需要 state 配合：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useRef, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> numRef = useRef &lt; number &gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> [, forceRender] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>
        <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
          numRef.current += 1;
          forceRender(Math.random());
        }}
      &gt;
        {numRef.current}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<h3><a id="forwardref--useimperativehandle" class="content__heading-anchor"></a>forwardRef + useImperativeHandle</h3>
<p>forwardRef 允许组件使用 ref 将 DOM 节点暴露给父组件，也就是 ref 从子组件传递到父组件</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { forwardRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyInput</span>(<span class="hljs-params">props, ref</span>) {
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<p>也就是转发组件内的 Ref 到父组件</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Guang</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">ForwardRefRenderFunction</span>&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt; = <span class="hljs-function">(<span class="hljs-params">
  props,
  ref
</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">const</span> <span class="hljs-title class_">WrapedGuang</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-title class_">Guang</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> ref = useRef &lt; <span class="hljs-title class_">HTMLInputElement</span> &gt; <span class="hljs-literal">null</span>;

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ref&quot;</span>, ref.<span class="hljs-property">current</span>);
    ref.<span class="hljs-property">current</span>?.<span class="hljs-title function_">focus</span>();
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">WrapedGuang</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>forwardRef 包裹的组件的类型是 React.forwardRefRenderFunction</p>
<ul>
<li>第一个类型参数是 ref 的 content 的类型</li>
<li>第二个类型参数是 props 的类型。</li>
</ul>
<p>如果需要暴露一些自定义内容</p>
<ul>
<li>需要 useImperativeHandle 的 hook 配合
<ul>
<li>它有 3 个参数
<ul>
<li>第一个是传入的 ref</li>
<li>第二个是是返回新的 ref 值的函数</li>
<li>第三个是依赖数组</li>
</ul></li>
</ul></li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { useImperativeHandle } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

interface <span class="hljs-title class_">RefProps</span> {
  <span class="hljs-attr">aaa</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">void</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Guang</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">ForwardRefRenderFunction</span>&lt;<span class="hljs-title class_">RefProps</span>&gt; = <span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> inputRef = useRef &lt; <span class="hljs-title class_">HTMLInputElement</span> &gt; <span class="hljs-literal">null</span>;

  <span class="hljs-title function_">useImperativeHandle</span>(
    ref,
    <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-title function_">aaa</span>(<span class="hljs-params"></span>) {
          inputRef.<span class="hljs-property">current</span>?.<span class="hljs-title function_">focus</span>();
        },
      };
    },
    [inputRef]
  );

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">const</span> <span class="hljs-title class_">WrapedGuang</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-title class_">Guang</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> ref = useRef &lt; <span class="hljs-title class_">RefProps</span> &gt; <span class="hljs-literal">null</span>;

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;ref&quot;</span>, ref.<span class="hljs-property">current</span>);
    ref.<span class="hljs-property">current</span>?.<span class="hljs-title function_">aaa</span>();
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">WrapedGuang</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>用 useImperativeHanlde 自定义 ref 对象，这样，父组件里拿到的 ref 就是 useImperativeHandle 第二个参数的返回值了。</p>
<h3><a id="usecontext" class="content__heading-anchor"></a>useContext</h3>
<p>跨任意层组件传递数据，我们一般用 Context。</p>
<p>展示值：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createContext, useContext } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">const</span> countContext = <span class="hljs-title function_">createContext</span>(<span class="hljs-number">111</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Aaa</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">countContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{222}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Bbb</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Bbb</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">countContext.Provider</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Bbb</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">Ccc</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ccc</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Ccc</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">useContext</span>(countContext);
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>context 的值为：{count}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Aaa</span>;
</code></pre>
<p>class 组件是通过 Consumer 来取 context 的值：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { createContext, <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">const</span> countContext = <span class="hljs-title function_">createContext</span>(<span class="hljs-number">111</span>);

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Ccc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>context 的 值为：{this.props.count}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Bbb</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">countContext.Consumer</span>&gt;</span>
        {(count) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Ccc</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{count}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Ccc</span>&gt;</span>}
      <span class="hljs-tag">&lt;/<span class="hljs-name">countContext.Consumer</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>总结:用 createContext 创建 context 对象，用 Provider 修改其中的值， function 组件使用 useContext 的 hook 来取值，class 组件使用 Consumer 来取值。</p>
<h3><a id="memo--usememo--usecallback" class="content__heading-anchor"></a>memo + useMemo + useCallback</h3>
<ul>
<li><p>memo 是防止 props 没变时的重新渲染，useMemo 和 useCallback 是防止 props 的不必要变化。</p></li>
<li><p>如果子组件用了 memo，那给它传递的 props 就需要用 useMemo、useCallback 包裹，否则，每次 props 都会变，memo 就没用了。</p></li>
<li><p>如果 props 使用 useMemo、useCallback，但是子组件没有被 memo 包裹，那也没意义，因为不管 props 变没变都会重新渲染，只是做了无用功。</p></li>
<li><p>memo + useCallback、useMemo 是搭配着来的，少了任何一方，都会使优化失效。但 useMemo 和 useCallback 也不只是配合 memo 用。</p></li>
<li><p>大计算量可以用 useMemo 来缓存</p></li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { memo, useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Aaa</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [, setNum] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">1</span>);

  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">2</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setNum</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());
    }, <span class="hljs-number">2000</span>);
  }, []);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setCount</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>());
    }, <span class="hljs-number">2000</span>);
  }, []);

  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">MemoBbb</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{count}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MemoBbb</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

interface <span class="hljs-title class_">BbbProps</span> {
  <span class="hljs-attr">count</span>: number;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">Bbb</span>(<span class="hljs-params">props: BbbProps</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bbb render&quot;</span>);

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{props.count}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">MemoBbb</span> = <span class="hljs-title function_">memo</span>(<span class="hljs-title class_">Bbb</span>);

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Aaa</span>;
</code></pre>
<h3><a id="react19-新增-hook" class="content__heading-anchor"></a>React19 新增 Hook</h3>
<ul>
<li>useFormState：重新定义交互性,简化服务器交互
<ul>
<li>管理表单提交状态，可以立即显示服务器响应</li>
<li>在表单操作期间，处理服务器通信，并捕获和展现服务器的响应结果</li>
<li>不需要通常的 useEffect + setMessage 组合。</li>
</ul></li>
<li>useFormStatus：让用户了解情况,增强表单提交体验
<ul>
<li>提供一个 pending 标志，在 true 或 false 之间切换以指示提交进度。</li>
<li>此标志对于在数据提交期间显示加载动画或更改按钮文本有很大帮助，从而保持用户参与并了解情况。</li>
</ul></li>
<li>useOptimistic：主动反馈
<ul>
<li>为 Web 应用程序添加了一层动态用户反馈</li>
<li>使用 useOptimistic 可以在用户互动后，在服务器响应之前立即进行操作，例如「正在加载仪表板」</li>
<li>通过预期的反馈可以通过使交互感觉更快、响应更灵敏来增强用户体验。</li>
<li>有点像动态的骨架屏</li>
</ul></li>
</ul>
<h2><a id="总结" class="content__heading-anchor"></a>总结</h2>
<ul>
<li><p>useState</p>
<ul>
<li>状态是变化的数据，是组件甚至前端应用的核心。useState 有传入值和函数两种参数，返回的 setState 也有传入值和传入函数两种参数。</li>
</ul></li>
<li><p>useEffect</p>
<ul>
<li>副作用 effect 函数是在渲染之外额外执行的一些逻辑。它是根据第二个参数的依赖数组是否变化来决定是否执行 effect，可以返回一个清理函数，会在下次 effect 执行前执行。</li>
</ul></li>
<li><p>useLayoutEffect</p>
<ul>
<li>和 useEffect 差不多，但是 useEffect 的 effect 函数是异步执行的，所以可能中间有次渲染，会闪屏</li>
<li>useLayoutEffect 则是同步执行的，所以不会闪屏，但如果计算量大可能会导致掉帧。</li>
</ul></li>
<li><p>useReducer</p>
<ul>
<li>封装一些修改状态的逻辑到 reducer，通过 action 触发，当修改深层对象的时候，创建新对象比较麻烦，可以结合 immer</li>
</ul></li>
<li><p>useRef</p>
<ul>
<li>可以保存 dom 引用或者其他内容，通过 xxRef.current 来取，改变它的内容不会触发重新渲染</li>
</ul></li>
<li><p>forwardRef</p>
<ul>
<li>通过 forwardRef 可以从子组件转发 ref 到父组件</li>
<li>如果想自定义 ref 内容可以使用 useImperativeHandle</li>
</ul></li>
<li><p>useContext</p>
<ul>
<li>跨层组件之间传递数据可以用 Context</li>
<li>用 createContext 创建 context 对象，用 Provider 修改其中的值， function 组件使用 useContext 的 hook 来取值，class 组件使用 Consumer 来取值</li>
</ul></li>
<li><p>useMemo、useCallback</p>
<ul>
<li>memo 包裹的组件只有在 props 变的时候才会重新渲染，useMemo、useCallback 可以防止 props 不必要的变化，两者一般是结合用。</li>
<li>不过当用来缓存计算结果等场景的时候，也可以单独用 useMemo、useCallback</li>
</ul></li>
<li><p>React 19 新增的 Hook</p>
<ul>
<li>useFormState：重新定义交互性</li>
<li>useFormStatus：让用户了解情况</li>
<li>useOptimistic：主动反馈</li>
</ul></li>
</ul>
<h2><a id="hook-闭包陷阱" class="content__heading-anchor"></a>Hook 闭包陷阱</h2>
<h3><a id="什么是闭包陷阱" class="content__heading-anchor"></a>什么是闭包陷阱</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);
      <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">1000</span>);
  }, []);

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<h3><a id="解决办法" class="content__heading-anchor"></a>解决办法</h3>
<h4><a id="第一种" class="content__heading-anchor"></a>第一种</h4>
<p>使用 useState 的函数的形式</p>
<ul>
<li>从参数拿到上次的 state，这样就不会形成闭包了</li>
<li>或者用 useReducer，直接 dispatch action，而不是直接操作 state，这样也不会形成闭包</li>
</ul>
<p>useState 的函数形式</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setCount</span>(<span class="hljs-function">(<span class="hljs-params">count</span>) =&gt;</span> count + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">1000</span>);
  }, []);

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>useReducer 的形式</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">Reducer</span>,useEffect,useReducer} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

interface <span class="hljs-title class_">Action</span> {
  <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;add&#x27;</span>|<span class="hljs-string">&#x27;minus&#x27;</span>;
  <span class="hljs-attr">num</span>:number;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state:number,action:Action</span>) {
  <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;add&#x27;</span>:
      <span class="hljs-keyword">return</span> state + action.<span class="hljs-property">num</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;minus&#x27;</span>:
      <span class="hljs-keyword">return</span> state - action.<span class="hljs-property">num</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count,dispatch] = useReducer&lt;<span class="hljs-title class_">Reducer</span>&lt;number,<span class="hljs-title class_">Action</span>&gt;&gt;(reducer,<span class="hljs-number">0</span>);

  <span class="hljs-title function_">uwseEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);

    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">dispatch</span>({
        <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;add&#x27;</span>,
        <span class="hljs-attr">num</span>: <span class="hljs-number">1</span>
      })
    })
  },[])

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;

</code></pre>
<h4><a id="第二种" class="content__heading-anchor"></a>第二种</h4>
<p>使用依赖数组实现，把用到的 state 加到依赖数组里，这样 state 变了就会重新跑 effect 函数，引用新的 state</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useEffect, useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count);

    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">1000</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">clearInterval</span>(timer);
    };
  }, [count]);

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<p>该方案不适用定时器<br>
定时器的场景需要保证定时器只跑一次，不然重新跑会导致定时不准，所以需要用 useEffect + useRef 的方式来解决闭包陷阱问题。</p>
<h4><a id="第三种-useref" class="content__heading-anchor"></a>第三种 useRef</h4>
<p>使用 useRef 保存每次渲染的值，用到的时候从 ref.current 中取.</p>
<p>通过 useRef 创建 ref 对象，保存执行的函数，每次渲染在 useLayoutEffect 里更新 ref.current 里的值为最新函数。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useEffect, useState, useRef, useLayoutEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateCount</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
  };
  <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(updateCount);

  <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> {
    ref.<span class="hljs-property">current</span> = updateCount;
  });

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> ref.<span class="hljs-title function_">current</span>(), <span class="hljs-number">1000</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-built_in">clearInterval</span>(timer);
    };
  }, []);

  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<h3><a id="扩展-封装定时器" class="content__heading-anchor"></a>扩展 封装定时器</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { useEffect, useState, useRef, useLayoutEffect, useCallback } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">useInterval</span>(<span class="hljs-params">fn: <span class="hljs-built_in">Function</span>, time: number</span>) {
    <span class="hljs-keyword">const</span> ref = <span class="hljs-title function_">useRef</span>(fn);

    <span class="hljs-title function_">useLayoutEffect</span>(<span class="hljs-function">() =&gt;</span> {
        ref.<span class="hljs-property">current</span> = fn;
    });

    <span class="hljs-keyword">let</span> cleanUpFnRef = useRef&lt;<span class="hljs-title class_">Function</span>&gt;();

    <span class="hljs-keyword">const</span> clean = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span>{
        cleanUpFnRef.<span class="hljs-property">current</span>?.();
    }, []);

    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> ref.<span class="hljs-title function_">current</span>(), time);

        cleanUpFnRef.<span class="hljs-property">current</span> = <span class="hljs-function">()=&gt;</span> {
            <span class="hljs-built_in">clearInterval</span>(timer);
        }

        <span class="hljs-keyword">return</span> clean;
    }, []);

    <span class="hljs-keyword">return</span> clean;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">const</span> <span class="hljs-title function_">updateCount</span> = (<span class="hljs-params"></span>) =&gt; {
        <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);
    };

    <span class="hljs-title function_">useInterval</span>(updateCount, <span class="hljs-number">1000</span>);

    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;

</code></pre>
 </article> </section> </main>  <footer class="footer"> <hr class="footer__divide"> <div class="footer__row"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">9Sky 九天</a> </p> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv>  项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> </footer> </body></html> 