<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>JavaScript探秘：原型与原型链</title><link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico"><link rel="sitemap" href="/sitemap-index.xml"><title>JavaScript探秘：原型与原型链</title><link rel="canonical" href="https://wty9sky.github.io/blog/detail/18/"><meta name="description" content="Javascript探秘系列:JavaScript中除了基础类型外的数据类型，都是对象（引用类型）。但是由于其没有类（class）的概念，如何将所有对象联系起来就成了一个问题，于是就有了原型和原型链的概念。

"><meta name="robots" content="index, follow"><meta property="og:title" content="JavaScript探秘：原型与原型链"><meta property="og:type" content="article"><meta property="og:image" content="/og.svg"><meta property="og:url" content="https://wty9sky.github.io/blog/detail/18/"><meta property="og:locale" content="zh_CN"><meta property="og:locale:alternate" content="zh_TW"><meta property="og:locale:alternate" content="en_US"><meta property="og:site_name" content="9Sky 九天"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/avatar.png"><meta name="generator" content="Astro v4.16.8"><meta name="keywords" content="详情"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.zJyvFudD.css">
<link rel="stylesheet" href="/_astro/about.DaaC2zNV.css"><script type="module" src="/_astro/hoisted.HO6_Fzad.js"></script></head> <body> <header class="header"> <h5 class="header__heading"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
JavaScript探秘：原型与原型链 </span> </h5> </header> <div id="navbar-sentinal"></div> <nav class="navbar" id="navbar-wrapper"> <div class="navbar__content"> <h5 class="navbar__path"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
JavaScript探秘：原型与原型链 </span> </h5> <div class="navbar__menu"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("#navbar-sentinal");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersectin && e[0].boundingClientRect.top <= 0) {
        headerEl.classList.add("navbar--sticked");
      } else {
        headerEl.classList.remove("navbar--sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>  <main class="page"> <section class="page__section page__section--at-top"> <!-- {
        article.cover && (
          <a href={article.cover} data-fancybox data-caption={article.title}>
            <img
              src={article.cover}
              alt={article.title}
              title={article.title}
              class="page__cover mb-8"
            />
          </a>
        )
      } --> <h1 class="page__heading">JavaScript探秘：原型与原型链</h1> <p class="page__meta"> <i class="ri-calendar-line"></i> <span>2019 年 6 月 8 日 02:15</span> </p> <hr class="page__divide"> <article class="content"> <h2><a id="文章目录" class="content__heading-anchor"></a>文章目录</h2>
<ul>
<li><a href="#javascript%E6%8E%A2%E7%A7%98%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE">JavaScript探秘：原型与原型链</a>
<ul>
<li><a href="#%E5%8E%9F%E5%9E%8B">原型</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E9%93%BE">原型链</a></li>
<li><a href="#%E9%9A%90%E5%BC%8F%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%98%BE%E5%BC%8F%E5%8E%9F%E5%9E%8B">隐式原型和显式原型</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E5%99%A8-constructor">构造器 constructor</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a>
<ul>
<li><a href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8">原型的作用：</a></li>
<li><a href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E4%BD%9C%E7%94%A8">原型链的作用：</a></li>
</ul></li>
</ul></li>
</ul>
<h1><a id="javascript探秘原型与原型链" class="content__heading-anchor"></a>JavaScript探秘：原型与原型链</h1>
<p><a href="https://wty9sky.api.swdwiki.com/resource/b56c970ead764f1c815d91e0d1bb614e" data-fancybox data-caption=""><img src="https://wty9sky.api.swdwiki.com/resource/b56c970ead764f1c815d91e0d1bb614e" alt="" title="" /></a></p>
<p><a href="https://wty9sky.api.swdwiki.com/resource/92d17320773c411cb9e4010186d62345" data-fancybox data-caption=""><img src="https://wty9sky.api.swdwiki.com/resource/92d17320773c411cb9e4010186d62345" alt="" title="" /></a></p>
<h2><a id="原型" class="content__heading-anchor"></a>原型</h2>
<p>JavaScript 原型是每个对象都具有的属性，它指向一个对象，通常称之为原型对象。<br>
当访问一个对象的属性或方法时，JavaScript 引擎首先会在该对象自身查找，如果找到则直接使用。如果找不到，则会去该对象的原型对象中查找。<br>
下面一个简单的例子来说明原型的概念：</p>
<pre><code class="language-js"><span class="hljs-comment">// 创建一个构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-comment">// 在构造函数的原型对象上定义方法</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
    <span class="hljs-string">&quot;Hello, my name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; and I am &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&quot; years old.&quot;</span>
  );
};

<span class="hljs-comment">// 创建一个对象</span>
<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);

<span class="hljs-comment">// 调用对象的方法</span>
person1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出：Hello, my name is Alice and I am 25 years old.</span>

<span class="hljs-comment">// person1 对象没有自己的 sayHello 方法，但它可以通过原型链找到 Person 构造函数的原型对象，并调用原型对象上的方法。</span>
</code></pre>
<p>定义了一个构造函数 Person，它有两个属性 name 和 age，并在构造函数的原型对象上定义了一个方法 sayHello。然后通过 new 关键字创建了一个对象 person1，然后就可以通过 person1.sayHello() 来调用原型对象上的方法。<br>
这里需要注意的是，所有通过 new 关键字创建的对象都会共享同一个原型对象，即它们的原型指向的是同一个对象。<br>
这就是 JavaScript 原型的基本概念和用法，它是实现继承和共享属性和方法的重要机制。</p>
<h2><a id="原型链" class="content__heading-anchor"></a>原型链</h2>
<p>JavaScript 中的原型链是基于对象的继承机制，它通过每个对象都具有一个指向其原型对象的内部链接来实现。<br>
当访问一个对象的属性或方法时，如果该对象本身该属性或方法，JavaScript 引擎会沿着对象的型链一直向上找，直到找到或者到达原型链的末端。如果最终还没有到，则返回 undefined。</p>
<p>下是一个简单的例子来说明型链的概念：</p>
<pre><code class="language-js"><span class="hljs-comment">// 定义一个构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-comment">// 在构造函数的原型对象上定义方法</span>
<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">food</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; is eating &quot;</span> + food);
};

<span class="hljs-comment">// 定义一个子构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params">name</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-comment">// 创建一个父对象实例</span>
<span class="hljs-keyword">var</span> animal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&quot;Tom&quot;</span>); <span class="hljs-comment">// 将父对象实例为子对象的原型</span>
<span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = animal;

<span class="hljs-comment">// 创建一个子对象实例</span>
<span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;Kitty&quot;</span>);

<span class="hljs-comment">// 调用子对象的方法</span>
cat.<span class="hljs-title function_">eat</span>(<span class="hljs-string">&quot;fish&quot;</span>); <span class="hljs-comment">// 输出：Kitty is eating fish</span>
</code></pre>
<p>定义了一个构造函数 Animal 和一个子构造函数 Cat。创建了一个父对象实例 animal，并在它的原型对象上定义了一个方法 。然后将父对象实例 animal 设置为子对象 Cat 的原型对象，这样子对象 cat 就可以通过原型链访问到父对象 animal 的属性和方法。<br>
当调用 cat.eat(&quot;fish&quot;) 时，由于 cat 对象本身没有 eat 方法，JavaScript 引擎会沿着原型链逐级向查找，找到父对象 animal 的 eat 方法，并执行。<br>
这就是 JavaScript 中原型链的基本原理：对象通过原型链实现属性和方法的承，每个对象通过内部链接指向其原型对象，形成一个链条。<br>
需要注意的是，原型链是单向的，子对象可以访问父对象属性和方法，但父对象不能访问子对象的属性和方法。</p>
<h2><a id="隐式原型和显式原型" class="content__heading-anchor"></a>隐式原型和显式原型</h2>
<p>隐式原型和显式原型是原型链中的两个重要概念。</p>
<p>隐式原型（<strong>proto</strong>）：每个对象都有一个隐式原型，它指向创建该对象的构造函数的原型对象。可以通过 obj.<strong>proto</strong>来访问对象的隐式原型。</p>
<p>显式原型（prototype）：每个构造函数都有一个显式原型，它是一个对象，用于存储该构造函数创建的对象共享的属性和方法。可以通过 constructor.prototype 来访问构造函数的显式原型。</p>
<p>区别：</p>
<p>隐式原型是每个对象都具有的属性，它是对象与构造函数之间的连接。而显式原型是构造函数才具有的属性，它定义了构造函数的实例对象共享的属性和方法。</p>
<p>隐式原型指向的是创建该对象的构造函数的原型对象，而显式原型指向的是构造函数的原型对象本身。</p>
<p>通过修改显式原型可以影响构造函数创建的所有对象的属性和方法，而修改隐式原型只会影响一个对象的原型链。</p>
<p>下面通过代码来说明隐式原型和显式原型的概念：</p>
<pre><code class="language-js"><span class="hljs-comment">// 定义构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<span class="hljs-comment">// 定义 name 属性</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age; <span class="hljs-comment">// 定义 age 属性</span>
}

<span class="hljs-comment">// 在构造函数的显式原型上定义一个方法</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};

<span class="hljs-comment">// 创建一个对象实例</span>
<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);

<span class="hljs-comment">// 访问对象的属性和方法</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>); <span class="hljs-comment">// 输出：Alice</span>
person1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出：Hello, my name is Alice</span>

<span class="hljs-comment">// 访问对象的隐式原型和显式原型</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.**proto**); <span class="hljs-comment">// 输出：指向构造函数的显式原型对象</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 输出：构造函数的显式原型对象</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.**proto** === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 输出：true</span>
</code></pre>
<p>定义了一个构造函数 Person，并在它的显式原型上定义了一个方法 sayHello。然后通过 new 关键字创建了一个对象实例 person1。<br>
可以通过 person1.name 访问对象的属性，通过 person1.sayHello() 调用对象的方法。<br>
由于对象 person1 是通过构造函数 Person 创建的，因此它的隐式原型指向的是 Person 构造函数的显式原型对象。通过 person1.<strong>proto 或者 Person.prototype 访问到显式原型对象。<br>
需要注意的是，</strong>proto__ 是一个非标准的属性，尽量避免在实际开发中直接使用它，而是使用 Object.getPrototypeOf() 或者 Object.setPrototypeOf() 来操作原型。</p>
<h2><a id="构造器-constructor" class="content__heading-anchor"></a>构造器 constructor</h2>
<p>构造器（constructor）是 JavaScript 中一种特殊的方法，用于创建和初始化对象。它通常用于构造函数（Constructor Function）中。<br>
构造函数是一种特殊的函数，用于创建对象。构造函数通常以大写字母开头，这是为了与普通函数做区分。构造函数除了用于创建对象外，还可以定义实例对象的属性和方法。<br>
构造器（constructor）是构造函数中的一个特殊方法，用于实例化对象时进行初始化操作。构造器的作用是在创建新对象的同时，给这个对象设置初始的属性和方法。</p>
<p>下面是一个示例，用于演示构造函数和构造器的概念和用法：</p>
<pre><code class="language-js"><span class="hljs-comment">// 定义一个构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-comment">// 构造器（constructor），用于初始化对象</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;

  <span class="hljs-comment">// 定义实例方法</span>
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
  };
}

<span class="hljs-comment">// 创建实例对象</span>
<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>);
<span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">30</span>);

<span class="hljs-comment">// 调用实例方法</span>
person1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出：Hello, my name is Alice</span>
person2.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出：Hello, my name is Bob</span>
</code></pre>
<p>在上面的示例中，定义了一个构造函数 Person，它接受两个参数 name 和 age，并在构造器中分别给实例对象设置了 name 和 age 属性。<br>
通过 new 关键字，可以实例化 Person 构造函数，创建了两个实例对象 person1 和 person2。每个实例对象都有自己独立的 name 和 age 属性。<br>
构造函数中定义了一个实例方法 sayHello，通过调用实例对象的 sayHello 方法，实例对象可以打印出自己的名字。<br>
需要注意的是，每个实例对象都会有一个独立的 sayHello 方法，这可能会导致内存占用较大。为了避免这个问题，可以使用原型方法的方式来定义方法，从而实现属性和方法的共享，提高代码内存利用率。例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// 定义一个构造函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}

<span class="hljs-comment">// 定义实例方法</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};
</code></pre>
<p>这样，每个实例对象共享一个 sayHello 方法，避免了重复创建实例方法的问题。<br>
总结起来，构造器（constructor）是构造函数中用于初始化对象的特殊方法。它在实例化对象时被调用，通过构造器可以给对象设置初始的属性和方法。构造函数和构造器在 JavaScript 开发中非常常见，有助于实现对象的创建和初始化。<br>
四、三个重要属性<br>
在 JavaScript 中，<strong>proto</strong>、prototype、constructor 是三个与原型链密切相关的属性或特性。</p>
<p><strong>proto</strong> 是一个非标准的属性，它是对象与构造函数之间的连接，它指向创建该对象的构造函数的原型对象。可以通过 obj.<strong>proto</strong> 来访问对象的隐式原型。</p>
<p>prototype 是函数对象所特有的属性，它是一个对象，用于存储该构造函数创建的对象共享的属性和方法。例如，通过 Person.prototype 可以定义 Person 构造函数创建的实例对象共享的方法。</p>
<p>constructor 是原型对象上的一个属性，它指向创建该对象的构造函数，Person.prototype.constructor 指向 Person 构造函数本身。</p>
<p>它们之间的关系如下：</p>
<p>对象的 <strong>proto</strong> 属性指向所属构造函数的 prototype 属性，即对象的隐式原型指向构造函数的显式原型。<br>
构造函数的 prototype 属性是一个普通对象，它具有 constructor 属性，指向创建该对象的构造函数自身。<br>
构造函数创建的通过隐式原型与构造函数的显式原型相连接，形成一个原型链。</p>
<p>举例来说明：</p>
<pre><code class="language-js"> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) {
<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
}

<span class="hljs-comment">// 通过构造函数的显式原型定义方法</span>
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHello</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};

<span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);
person1.<span class="hljs-title function_">sayHello</span>(); <span class="hljs-comment">// 输出：Hello, my name is Alice</span>

<span class="hljs-comment">// 隐式原型和显式原型的关系</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.**proto** === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>); <span class="hljs-comment">// 输出：true</span>

<span class="hljs-comment">// 构造函数和原型对象关系</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// 输出：true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>); <span class="hljs-comment">// 输出：true</span>
</code></pre>
<p>通过构造函数 Person 和其原型对象 Person.prototype 实现了对象 person1 的属性和方法的共享。<br>
person1.<strong>proto</strong> 指向构造函数 Person 的 prototype，因此隐式原型和显式原型是相连的。<br>
person1.constructor 指向 Person 构造函数本身，而 Person.prototype.constructor 也指向 Person 构造函数。<br>
这种关系形成了一个完整的原型链，实现了属性和方法的继承和共享。</p>
<h2><a id="总结" class="content__heading-anchor"></a>总结</h2>
<p>原型和原型链是 JavaScript 中非常重要的概念，理解它们的作用对于开发和理解 JavaScript 代码非常重要。</p>
<h3><a id="原型的作用" class="content__heading-anchor"></a>原型的作用：</h3>
<p>实现属性和方法的共享：通过原型，可以将对象的属性和方法存储在原型对象中，从而实现多个对象之间的属性和方法的共享，避免了在每个对象实例中复制相同的属性和方法，节省了内存空间。<br>
实现对象的继承：通过原型链，可以创建对象之间的继承关系，子对象可以继承父对象的属性和方法，并在此基础上进行扩展，实现了对象之间的继承和多态特性。</p>
<h3><a id="原型链的作用" class="content__heading-anchor"></a>原型链的作用：</h3>
<p>属性和方法的查找：当访问对象的属性或方法时，首先在自身对象中查找，如果找不到，则沿着原型链向上查找，直到找到该属性或方法为止。这样可以实现属性和方法的继承和共享，提高代码的重用性。<br>
原型链的终点是 Object.prototype，它是所有对象的基础原型，包括 JavaScript 内置对象和自定义对象。</p>
<ul>
<li>JavaScript 是一门基于原型和原型链的面向对象的语言，理解原型和原型链是深入理解 JavaScript 语本身的必备基础。</li>
<li>理解原型和原型链可以更好地理解和使用 JavaScript 的核心特性，如继承、原型继承、对象创建等。</li>
<li>原型和原型链是深入学习和理解 JavaScript 高级特性的前提基础，如闭包、作用域、模块化等。</li>
<li>在实际开发中，原型和原型链相关的知识经常用于设计和构建复杂的 JavaScript 应用、设计模式和代码优化。</li>
</ul>
 </article> </section> </main>  <footer class="footer"> <hr class="footer__divide"> <div class="footer__row"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">9Sky 九天</a> </p> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv>  项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> </footer> </body></html> 