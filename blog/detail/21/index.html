<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>Vue3源码解析：VueRouter原理挖掘机</title><link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico"><link rel="sitemap" href="/sitemap-index.xml"><title>Vue3源码解析：VueRouter原理挖掘机</title><link rel="canonical" href="https://wty9sky.github.io/blog/detail/21/"><meta name="description" content="Vue3源码解析：VueRouter原理挖掘机"><meta name="robots" content="index, follow"><meta property="og:title" content="Vue3源码解析：VueRouter原理挖掘机"><meta property="og:type" content="article"><meta property="og:image" content="/og.svg"><meta property="og:url" content="https://wty9sky.github.io/blog/detail/21/"><meta property="og:locale" content="zh_CN"><meta property="og:locale:alternate" content="zh_TW"><meta property="og:locale:alternate" content="en_US"><meta property="og:site_name" content="9Sky 九天"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/avatar.png"><meta name="generator" content="Astro v4.16.7"><meta name="keywords" content="详情"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.zJyvFudD.css">
<link rel="stylesheet" href="/_astro/about.D3zQv4Ly.css"><script type="module" src="/_astro/hoisted.HO6_Fzad.js"></script></head> <body> <header class="header"> <h5 class="header__heading"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
Vue3源码解析：VueRouter原理挖掘机 </span> </h5> </header> <div id="navbar-sentinal"></div> <nav class="navbar" id="navbar-wrapper"> <div class="navbar__content"> <h5 class="navbar__path"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
Vue3源码解析：VueRouter原理挖掘机 </span> </h5> <div class="navbar__menu"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("#navbar-sentinal");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersectin && e[0].boundingClientRect.top <= 0) {
        headerEl.classList.add("navbar--sticked");
      } else {
        headerEl.classList.remove("navbar--sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>  <main class="page"> <section class="page__section page__section--at-top"> <!-- {
        article.cover && (
          <a href={article.cover} data-fancybox data-caption={article.title}>
            <img
              src={article.cover}
              alt={article.title}
              title={article.title}
              class="page__cover mb-8"
            />
          </a>
        )
      } --> <h1 class="page__heading">Vue3源码解析：VueRouter原理挖掘机</h1> <p class="page__meta"> <i class="ri-calendar-line"></i> <span>2022 年 8 月 18 日 02:37</span> </p> <hr class="page__divide"> <article class="content"> <h2><a id="文章目录" class="content__heading-anchor"></a>文章目录</h2>
<ul>
<li><a href="#vuerouter%E5%8E%9F%E7%90%86%E6%8C%96%E6%8E%98%E6%9C%BA">VueRouter原理挖掘机</a>
<ul>
<li><a href="#%E5%88%86%E6%9E%90-vue-router">分析 Vue Router</a>
<ul>
<li><a href="#install-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">install 方法实现</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">实现构造函数</a></li>
<li><a href="#createroutemap-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">createRouteMap 方法实现</a></li>
<li><a href="#initcomponents-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">initComponents 方法实现</a></li>
<li><a href="#render-%E5%87%BD%E6%95%B0">render 函数</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA-router-view-%E7%BB%84%E4%BB%B6">创建 router-view 组件</a></li>
<li><a href="#initevent-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">initEvent 方法实现</a></li>
</ul></li>
<li><a href="#vuerouter-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB">VueRouter 模拟实现与源码解读</a>
<ul>
<li><a href="#vueuse%E6%BA%90%E7%A0%81">Vue.use()源码</a></li>
<li><a href="#install-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90">install 方法分析</a></li>
<li><a href="#%E7%BB%84%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95">组件创建测试</a></li>
<li><a href="#%E8%A7%A3%E6%9E%90%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99">解析路由规则</a></li>
<li><a href="#match-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0">match 函数实现</a></li>
<li><a href="#%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E5%A4%84%E7%90%86">历史记录处理</a></li>
<li><a href="#init-%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0">Init 方法实现</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84_route">设置响应式的_route</a></li>
<li><a href="#routerouter-%E5%88%9B%E5%BB%BA"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">route/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span>router 创建</a></li>
<li><a href="#router-view-%E5%88%9B%E5%BB%BA">Router-View 创建</a></li>
<li><a href="#routerouter-%E5%88%9B%E5%BB%BA-1"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">route/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span>router 创建</a></li>
<li><a href="#router-view-%E5%88%9B%E5%BB%BA-1">Router-View 创建</a></li>
</ul></li>
</ul></li>
</ul>
<h1><a id="vuerouter原理挖掘机" class="content__heading-anchor"></a>VueRouter原理挖掘机</h1>
<p>本篇主要模拟的是 History 模式。Hash 模式基本实现上是一样的。</p>
<p>这里先来复习一下 Hash 模式的工作原理。</p>
<p>·URL 中#后面的内容作为路径地址，当地址改变的时候不会向服务器发送请求，但是会触发 hashchange 事件。<br>
监听 hashchange 事件，在该事件中记录当前的路由地址，然后根据路由地址找到对应组件。<br>
根据当前路由地址找到对应组件重新渲染。<br>
下面再来复习一下 History 模式</p>
<p>通过 history.pushState()方法改变地址栏，并且将当前地址记录到浏览器的历史记录中。当前浏览器不会向服务器发送请求<br>
监听 popstate 事件，可以发现浏览器历史操作的变化，记录改变后的地址，单击前进或者是后退按钮的时候触发该事件<br>
根据当前路由地址找到对应组件重新渲染</p>
<h2><a id="分析-vue-router" class="content__heading-anchor"></a>分析 Vue Router</h2>
<p>在模拟 Vue Router 之前，首先来看一下 Vue Router 的核心代码</p>
<pre><code class="language-javascript"><span class="hljs-comment">//注册插件</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">VueRouter</span>);
<span class="hljs-comment">//创建路由对象</span>
<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({
  <span class="hljs-attr">routes</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;home&quot;</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">component</span>: homeComponent }],
});
<span class="hljs-comment">// 创建Vue实例，注册router对象</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  router,
  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),
}).$mount(<span class="hljs-string">&quot;#apps&quot;</span>);
</code></pre>
<p>在上面的代码中，我们首先调用 use 方法注册该插件。</p>
<p>use 方法需要的参数可以是一个函数或者是对象，如果传递的是函数，use 内部会直接调用该函数，</p>
<p>如果传递的是一个对象，那么在 use 内部会调用该对象的 install 方法。</p>
<p>而 Vue Router 传递的是对象，所以在模拟 Vue Router 的时候，要实现一个 install 方法。</p>
<p>下面我们创建了 VueRouter 实例，所以 VueRouter 可以是构造方法或者是类，那么我们在模拟的时候，将其定义为类。并且该类中有一个静态的 install 方法，因为我们将 VueRouter 传递给了 use 方法。</p>
<p>在 VueRouter 类的构造方法中，需要有一个参数，该参数是一个对象，该对象中定义了路由的规则。</p>
<p>最后创建了 Vue 的实例，并且将创建好的 Vue Router 对象传递到该实例中。</p>
<p>在该类图中，上半部分是 VueRouter 的属性，而下半部分是 VueRouter 的方法。</p>
<p>options 作用是记录构造函数中传入的对象, 我们在创建 Vue Router 的实例的时候，传递了一个对象，而该对象中定义了路由规则。而 options 就是记录传入的这个对象的。</p>
<p>routeMap:是一个对象，记录路由地址与组件的对应关系，也就是一个键值对的形式，后期会 options 中路由规则解析到 routeMap 中。</p>
<p>data 是一个对象，该对象中有一个属性 current,该属性用来记录当前的路由地址，data 是一个响应式的对象，因为当前路由地址发生变化后，对应的组件要发生更新（也就说当地址变化后，要加载对应组件）。</p>
<p>install 是一个静态方法，用来实现 Vue 的插件机制。</p>
<p>Constructor 是一个构造方法，该该构造方法中会初始化 options ,data,routeMap 这几个属性。</p>
<p>inti 方法主要是用来调用下面的三个方法，也就把不同的代码分隔到不同的方法中去实现。</p>
<p>initEvent 方法，用来注册 popstate 事件，</p>
<p>createRouteMap 方法，该方法会把构造函数中传入进来的路由规则，转换成键值对的形式存储到 routeMap 中。 键就是路由的地址，值就是对应的组件</p>
<p>initComponents 方法，主要作用是用来创建 router-link 和 router-view 这两个组件的。</p>
<p>现在我们已经对 Vue Router 做了一个分析。</p>
<p>下面开始创建自己的 Vue Router.</p>
<h3><a id="install-方法实现" class="content__heading-anchor"></a>install 方法实现</h3>
<p>在 Vue_router_app 项目的 src 目录下面创建一个 Vuerouter 目录，同时创建一个 index.js 文件，在该文件中创建如下的代码。</p>
<p>install 方法需要的参数是 Vue 的构造方法。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> _Vue = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VueRouter</span> {
  <span class="hljs-comment">//调用install方法的时候，会传递Vue的构造函数</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue</span>) {
    <span class="hljs-comment">//首先判断插件是否已经被安装，如果已经被安装，就不需要重复安装。</span>
    <span class="hljs-comment">//1、判断当前插件是否已经被安装:</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">VueRouter</span>.<span class="hljs-property">install</span>.<span class="hljs-property">installed</span>) {
      <span class="hljs-comment">//条件成立，表明插件已经被安装，什么都不要做。</span>
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-title class_">VueRouter</span>.<span class="hljs-property">install</span>.<span class="hljs-property">installed</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-comment">//2、把Vue构造函数记录到全局变量中。</span>
    _Vue = <span class="hljs-title class_">Vue</span>;

    <span class="hljs-comment">//3、把创建Vue实例时候传入的router对象注入到Vue实例上。</span>
    _Vue.<span class="hljs-title function_">mixin</span>({
      <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">//在创建Vue实例的时候</span>
        <span class="hljs-comment">// 也就是new Vue()的时候，才会有$options这个属性，</span>
        <span class="hljs-comment">//组件中是没有$options这个属性的。</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>) {
          _Vue.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>;
        }
      },
    });
  }
}
</code></pre>
<h3><a id="实现构造函数" class="content__heading-anchor"></a>实现构造函数</h3>
<p>Constructor 是一个构造方法，该该构造方法中会初始化 options ,data,routeMap 这几个属性。</p>
<pre><code class="language-javascript"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = options;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routeMap</span> = {};

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = _Vue.<span class="hljs-title function_">observable</span>({
      <span class="hljs-attr">current</span>: <span class="hljs-string">&quot;/&quot;</span>,
    });
  }
</code></pre>
<h3><a id="createroutemap-方法实现" class="content__heading-anchor"></a>createRouteMap 方法实现</h3>
<p>createRouteMap 方法，该方法会把构造函数中传入进来的 options 参数中的路由规则，转换成键值对的形式存储到 routeMap 中。 键就是路由的地址，值就是对应的组件</p>
<pre><code class="language-javascript">  <span class="hljs-title function_">createRouteMap</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">routes</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">routeMap</span>[route.<span class="hljs-property">path</span>] = route.<span class="hljs-property">component</span>;
    });
  }
</code></pre>
<h3><a id="initcomponents-方法实现" class="content__heading-anchor"></a>initComponents 方法实现</h3>
<p>initComponents 方法，主要作用是用来创建 router-link 和 router-view 这两个组件的。</p>
<p>下面先在这个方法中创建 router-link 这个组件。</p>
<p>先来看一下 router-link 这个组件的基本使用</p>
<pre><code class="language-javascript">&lt;router-link to=<span class="hljs-string">&quot;/users&quot;</span>&gt; 用户管理&lt;/router-link&gt;
</code></pre>
<p>我们知道，router-link 这个组件最终会被渲染成 a 标签，同时 to 作为一个属性，其值会作为 a 标签中的 href 属性的值。同时还要获取&lt;\router-link&gt;这个组件中的文本，作为最终超链接的文本。</p>
<pre><code class="language-javascript"> <span class="hljs-title function_">initComponents</span>(<span class="hljs-params">Vue</span>) {
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;router-link&quot;</span>, {
      <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">to</span>: <span class="hljs-title class_">String</span>,
      },
      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;a :href=&quot;to&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;&#x27;</span>,
    });
  }
</code></pre>
<p>在上面的代码中，我们通过 Vue.component 来创建 router-link 这个组件，同时通过 props 接收 to 属性传递过来的值，并且对应的类型为字符串。</p>
<p>最终渲染的模板是一个 a 标签，href 属性绑定了 to 属性的值，同时使用&lt;\slot&gt;插槽作为占位符，用具体的文字内容填充该占位符。</p>
<p>现在已经将 router-link 这个组件创建好了。</p>
<p>下面我们需要对我们写的这些代码进行测试。</p>
<p>要进行测试应该先将 createRouteMap 方法与 initComponents 方法都调用一次，那么问题是</p>
<p>在什么时候调用这两个方法呢？</p>
<p>我们可以在 VueRoute 对象创建成功后，并且将 VueRouter 对象注册到 Vue 的实例上的时候，调用这两个方法。</p>
<p>也就是在 beforeCreate 这个钩子函数中。</p>
<p>当然为了调用这两个方便，在这里我们又定义了 init 方法，来做了一次封装处理。</p>
<pre><code class="language-javascript">  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createRouteMap</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initComponents</span>(_Vue);
  }
</code></pre>
<p>对 init 方法的调用如下：</p>
<pre><code class="language-javascript">   <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) {
        <span class="hljs-comment">//在创建Vue实例的时候</span>
        <span class="hljs-comment">// 也就是new Vue()的时候，才会有$options这个属性，</span>
        <span class="hljs-comment">//组件中是没有$options这个属性的。</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>) {
          _Vue.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>;
            <span class="hljs-comment">//调用init</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">init</span>();
        }
      },

<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>.<span class="hljs-title function_">init</span>();
</code></pre>
<p>这句代码的含义：this 表示的就是 Vue 实例，$options 表示的就是在创建 Vue 的实例的时候传递的选项，如下所示：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,
  router,
});
</code></pre>
<p>通过上面的代码，我们可以看到，传递过来的选项中是有 router.</p>
<p>而这个 router 是什么呢？</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>({});
</code></pre>
<p>就是 VueRouter 这个类的实例。而我们当前自己所模拟的路由,所创建的类就叫做 VueRouter（也就是以后在创建路由实例的时候，使用我们自己创建的 VueRouter 这个类来完成）.</p>
<p>而 init 方法就是 VueRouter 这个类的实例方法。所以可以通过 this.$options.router.init()的方式来调用。</p>
<p>下面我们来测试一下。</p>
<p>在 Vue_router_app 项目的 src 目录下面，创建 router.js 文件,文件定义路由规则.</p>
<p>如下代码所示：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;Vue&quot;</span>;
<span class="hljs-comment">// import Router from &quot;Vue-router&quot;;</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Vuerouter&quot;</span>; <span class="hljs-comment">//注意:这里导入的是自己定义的路由规则</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Login.Vue&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Home.Vue&quot;</span>;
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>({
  <span class="hljs-attr">model</span>: <span class="hljs-string">&quot;history&quot;</span>,
  <span class="hljs-attr">routes</span>: [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> },
    { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Login</span> },
  ],
});
</code></pre>
<p>在 components 目录下面分别创建 Home.Vue 与 Login.Vue.</p>
<p>Home.Vue 的代码如下：</p>
<pre><code class="language-javascript">&lt;template&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span>
&lt;/template&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>Login.Vue 的代码如下:</p>
<pre><code class="language-javascript">&lt;template&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    登录页面
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>App.Vue 组件的内容如下：</p>
<pre><code class="language-javascript">&lt;template&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>在 main.js 中完成路由的注册。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;Vue&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.Vue&quot;</span>;
<span class="hljs-comment">//导入router.js</span>
<span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./router&quot;</span>;
<span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">productionTip</span> = <span class="hljs-literal">false</span>;

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  router,
  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">h</span>) =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),
}).$mount(<span class="hljs-string">&quot;#app&quot;</span>);
</code></pre>
<p>运行上面的代码会出现如下的错误：</p>
<p>第二个错误是我们还没有创建 router-view 这个组件，所以才会出现该错误。这里暂时可以先不用考虑。</p>
<p>主要是第一个错误，该错误的含义是，目前我们使用的是运行时版本的 Vue, 模板编译器不可用。</p>
<p>你可以使用预编译把模板编译成 render 函数，或者是使用包含编译版本的 Vue.</p>
<p>以上错误说明了 Vue 的构建版本有两个，分别是“运行时版”和&quot;完整版&quot;.</p>
<p>运行时版：不支持 template 模板，需要打包的时候提前编译。</p>
<p>完整版：包含运行时和编译器，体积比运行时版大 10k 左右，程序运行的时候把模板转换成 render 函数。性能低于运行时版本。</p>
<p>使用 Vue-cli 创建的项目默认为运行时版本,而我们创建的 VueRouter 类中有 template 模板，所以才会出现第一个错误。</p>
<p>官方文档：https://cn.Vuejs.org/v2/guide/installation.html</p>
<p>下面我们看一下解决方案：</p>
<p>在前面我们已经提到过，使用 Vue-cli 创建的项目是运行时项目，所以没有编译器，如果我们将其修改成完整版，就有编译器，对模板进行编译。</p>
<p>解决的方案：在项目的根目录创建 Vue.config.js 文件，在该文件中添加 runtimeCompiler 配置项，该配置项表示的是，是否使用包含运行时编译器的 Vue 构建</p>
<p>版本（完整版）。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。默认该选项的取值为 false.</p>
<p>Vue.config.js 文件配置如下</p>
<pre><code class="language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">runtimeCompiler</span>: <span class="hljs-literal">true</span>,
};
</code></pre>
<p>表示使用的是完整版，这时编译器会将 template 选项转换成 render 函数。</p>
<p>注意：要想以上配置内容起作用，必须重新启动服务器。</p>
<pre><code class="language-bash">npm run serve
</code></pre>
<h3><a id="render-函数" class="content__heading-anchor"></a>render 函数</h3>
<p>虽然使用完整版 Vue 可以解决上面的问题，但是由于带有编译器，体积比运行时版本大 10k 左右，所以性能比运行时版要低。</p>
<p>那么这一小节我们使用运行时版本来解决这个问题。</p>
<p>我们知道，完整版中的编译器的作用就是将 template 模板转成 render 函数，所以在运行时版本中我们可以自己编写 render 函数。</p>
<p>但是在这你肯定也有一个问题，就是在单文件组件中，我们一直都是在写&lt;\template&gt;&lt;/template&gt;,并且没有写 render 函数，</p>
<p>但是为什么能够正常的工作呢？这时因为在打包的时候，将&lt;\template&gt;编译成了 render 函数，这就是预编译。</p>
<p>最终代码如下：</p>
<pre><code class="language-javascript"> <span class="hljs-comment">//该方法需要一个参数为Vue的构造函数。</span>
  <span class="hljs-comment">//当然也可以使用全局的_Vue.</span>
  <span class="hljs-title function_">initComponents</span>(<span class="hljs-params">Vue</span>) {
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;router-link&quot;</span>, {
      <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">to</span>: <span class="hljs-title class_">String</span>,
      },
      <span class="hljs-comment">// template: &#x27;&lt;a :href=&quot;to&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;&#x27;,</span>
      <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {

        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(
          <span class="hljs-string">&quot;a&quot;</span>,
          {
            <span class="hljs-attr">attrs</span>: {
              <span class="hljs-attr">href</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>,
            },
          },
          [<span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>]
        );
      },
    });
  }
</code></pre>
<p>注意：在测试之前一定要将根目录下的 Vue.config.js 文件删除掉，这样当前的环境为“运行时”环境。</p>
<h3><a id="创建-router-view-组件" class="content__heading-anchor"></a>创建 router-view 组件</h3>
<p>router-view 组件就是一个占位符。当根据路由规则找到组件后，会渲染到 router-view 的位置。</p>
<p>在 initComponents 方法中创建 router-view 组件</p>
<pre><code class="language-javascript"> <span class="hljs-comment">//该方法需要一个参数为Vue的构造函数。</span>
  <span class="hljs-comment">//当然也可以使用全局的_Vue.</span>
  <span class="hljs-title function_">initComponents</span>(<span class="hljs-params">Vue</span>) {
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;router-link&quot;</span>, {
      <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">to</span>: <span class="hljs-title class_">String</span>,
      },
      <span class="hljs-comment">// template: &#x27;&lt;a :href=&quot;to&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;&#x27;,</span>
      <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {

        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(
          <span class="hljs-string">&quot;a&quot;</span>,
          {
            <span class="hljs-attr">attrs</span>: {
              <span class="hljs-attr">href</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>,
            },
          },
          [<span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>]
        );
      },
    });
    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<span class="hljs-comment">//修改this的指向</span>
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;router-view&quot;</span>, {
      <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {
        <span class="hljs-comment">//根据当前的路径从routeMap中查找对应的组件.</span>
        <span class="hljs-keyword">const</span> component = self.<span class="hljs-property">routeMap</span>[self.<span class="hljs-property">data</span>.<span class="hljs-property">current</span>];
        <span class="hljs-comment">//将组件转换成虚拟dom</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(component);
      },
    });
  }
</code></pre>
<p>下面，我们可以测试一下效果。</p>
<p>当我们单击链接的时候，发现了浏览器进行了刷新操作。表明向服务器发送了请求，而我们单页面应用中是不希望向服务器发送请求。</p>
<p>修改后的 initComponents 方法如下：</p>
<pre><code class="language-javascript"> <span class="hljs-comment">//该方法需要一个参数为Vue的构造函数。</span>
  <span class="hljs-comment">//当然也可以使用全局的_Vue.</span>
  <span class="hljs-title function_">initComponents</span>(<span class="hljs-params">Vue</span>) {
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;router-link&quot;</span>, {
      <span class="hljs-attr">props</span>: {
        <span class="hljs-attr">to</span>: <span class="hljs-title class_">String</span>,
      },
      <span class="hljs-comment">// template: &#x27;&lt;a :href=&quot;to&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;&#x27;,</span>
      <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {

        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(
          <span class="hljs-string">&quot;a&quot;</span>,
          {
            <span class="hljs-attr">attrs</span>: {
              <span class="hljs-attr">href</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>,
            },
            <span class="hljs-attr">on</span>: {
              <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">clickHandler</span>,
            },
          },
          [<span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>]
        );
      },
      <span class="hljs-attr">methods</span>: {
        <span class="hljs-title function_">clickHandler</span>(<span class="hljs-params">e</span>) {

          history.<span class="hljs-title function_">pushState</span>({}, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>);

          <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-property">data</span>.<span class="hljs-property">current</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span>;

          <span class="hljs-comment">//阻止向服务器发送器。</span>
          e.<span class="hljs-title function_">preventDefault</span>();
        },
      },
    });
    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;router-view&quot;</span>, {
      <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {
        <span class="hljs-comment">//根据当前的路径从routeMap中查找对应的组件.</span>
        <span class="hljs-keyword">const</span> component = self.<span class="hljs-property">routeMap</span>[self.<span class="hljs-property">data</span>.<span class="hljs-property">current</span>];
        <span class="hljs-comment">//将组件转换成虚拟dom</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(component);
      },
    });
  }
</code></pre>
<p>给 a 标签添加了单击事件。</p>
<h3><a id="initevent-方法实现" class="content__heading-anchor"></a>initEvent 方法实现</h3>
<p>现在有一个问题就是，当点击浏览器中的后退与前进按钮的时候，地址栏中的地址发生了变化，但是对应的组件没有发生变化。</p>
<p>这时候要解决这个问题， 就需要用到 popstate 事件</p>
<p>popstate 事件，可以发现浏览器历史操作的变化，记录改变后的地址，单击前进或者是后退按钮的时候触发该事件</p>
<pre><code class="language-javascript"><span class="hljs-title function_">initEvent</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;popstate&quot;</span>, <span class="hljs-function">() =&gt;</span> {

      <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span>.<span class="hljs-property">current</span> = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">pathname</span>;
    });
  }
</code></pre>
<p>针对 initEvent 方法的调用如下：</p>
<pre><code class="language-javascript"><span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createRouteMap</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initComponents</span>(_Vue);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initEvent</span>();
  }
</code></pre>
<h2><a id="vuerouter-模拟实现与源码解读" class="content__heading-anchor"></a>VueRouter 模拟实现与源码解读</h2>
<p>在第二章中，我们已经对 VueRouter 做了一个基本的实现，通过这个基本的实现，已经对 VueRouter 的原理有了一个基本的理解。</p>
<p>但是，我们并没有实现路由嵌套的形式，这次我们重点来实现这一点。</p>
<h3><a id="vueuse源码" class="content__heading-anchor"></a>Vue.use()源码</h3>
<p>源码位置：Vue/src/core/global-api/use.js</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initUse</span>(<span class="hljs-params">Vue: GlobalAPI</span>) {
  <span class="hljs-comment">//use方法的参数接收的是一个插件，该插件的类型可以是一个函数，也可以是一个对象</span>
  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">use</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">plugin: <span class="hljs-built_in">Function</span> | <span class="hljs-built_in">Object</span></span>) {
    <span class="hljs-comment">//_installedPlugins数组中存放已经安装的插件。</span>
    <span class="hljs-keyword">const</span> installedPlugins =
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_installedPlugins</span> || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_installedPlugins</span> = []);
    <span class="hljs-comment">//判断一下传递过来的插件是否在installedPlugins中存在，如果存在，则直接返回</span>
    <span class="hljs-keyword">if</span> (installedPlugins.<span class="hljs-title function_">indexOf</span>(plugin) &gt; -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
    }

    <span class="hljs-comment">// additional parameters</span>
    <span class="hljs-comment">//将arguments转换成数组，并且将数组中的第一项去除。</span>
    <span class="hljs-keyword">const</span> args = <span class="hljs-title function_">toArray</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">//把this(也就是Vue，这里是通过Vue.use来调用的)插入到数组中的第一个元素的位置。</span>
    args.<span class="hljs-title function_">unshift</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-comment">//这时plugin是一个对象，看一下是否有install这个函数。</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin.<span class="hljs-property">install</span> === <span class="hljs-string">&quot;function&quot;</span>) {
      <span class="hljs-comment">//如果有install这个函数，直接调用</span>
      <span class="hljs-comment">//这里通过apply将args数组中的每一项展开传递给install这个函数。</span>
      <span class="hljs-comment">// plugin.install(args[0],args[1])</span>
      <span class="hljs-comment">//而args[0],就是上面我们所插入的Vue.这一点与我们前面在模拟install方法的时候是一样的。</span>
      plugin.<span class="hljs-property">install</span>.<span class="hljs-title function_">apply</span>(plugin, args);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">&quot;function&quot;</span>) {
      <span class="hljs-comment">//如果plugin是一个函数，则直接通过apply去调用</span>
      plugin.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);
    }
    <span class="hljs-comment">//将插件存储到installedPlugins数组中。</span>
    installedPlugins.<span class="hljs-title function_">push</span>(plugin);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
  };
}
</code></pre>
<h3><a id="install-方法分析" class="content__heading-anchor"></a>install 方法分析</h3>
<p>我们先来看一下 Vue-router 的目录结构</p>
<p>我们先来核心的文件。</p>
<p>components 目录下面，有两个文件。分别为 link.js 和 view.js 文件。</p>
<p>link.js 文件创建 RouterLink 组件</p>
<p>view.js 文件创建 RouterView 组件。</p>
<p>history 目录下的文件是记录路由的历史记录（hash.js 文件是关于 hash 模式，html5.js 关于 html5 的方式，base.js 公共的内容，abstract.js 是在服务端渲染中实现的路由历史记录）。</p>
<p>index.js 文件是用来创建 VueRouter</p>
<p>install.js 文件是关于 install 方法</p>
<p>我们自己模拟的 VueRouter 也实现上面的目录结构。</p>
<p>下面先来在 index.js 文件中实现基本代码。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VueRouter</span> {
  <span class="hljs-comment">//在创建VueRouter对象的时候，会传递选项</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-comment">//获取routes选项，该选项中定义路由规则</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_options</span> = options.<span class="hljs-property">routes</span> || [];
  }
  <span class="hljs-comment">// 注册路由变化的事件。该方法的参数是一个Vue实例，后期完善</span>
  <span class="hljs-title function_">init</span>(<span class="hljs-params">Vue</span>) {}
}
</code></pre>
<p>下面实现 install.js 基本代码（通过查看源代码来实现）</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> _Vue = <span class="hljs-literal">null</span>; <span class="hljs-comment">//将其导出，在其它文件中也可以使用Vue实例，而不需要单独的引入Vue的js文件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue</span>) {
  <span class="hljs-comment">//获取Vue构造函数</span>
  _Vue = <span class="hljs-title class_">Vue</span>;
  _Vue.<span class="hljs-title function_">mixin</span>({
    <span class="hljs-comment">//通过混入以后，所有的Vue实例中都会有beforeCreate方法</span>
    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) {
      <span class="hljs-comment">//判断是否为Vue的实例，如果条件成立为Vue的实例，否则为其它对应的组件（因为在创建Vue实例的时候会传递选项）</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>) {
        <span class="hljs-comment">//通过查看源码发现，Vue的实例会挂在到当前的私有属性_routerRoot属性上</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span> = <span class="hljs-variable language_">this</span>;

        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>;
        <span class="hljs-comment">//调用index.js文件中定义的init方法</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-title function_">init</span>(<span class="hljs-variable language_">this</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">_routerRoot</span>;
      }
    },
  });
}
</code></pre>
<h3><a id="组件创建测试" class="content__heading-anchor"></a>组件创建测试</h3>
<p>下面需要将 install 方法挂载到 VueRouter 上。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> install <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./install&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VueRouter</span> {
  <span class="hljs-comment">//在创建VueRouter对象的时候，会传递选项</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-comment">//获取routes选项，该选项中定义路由规则</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routes</span> = options.<span class="hljs-property">routes</span> || [];
  }
  <span class="hljs-comment">// 注册路由变化的事件。</span>
  <span class="hljs-title function_">init</span>(<span class="hljs-params">Vue</span>) {}
}
<span class="hljs-comment">//将install方法挂载到VueRouter上</span>
<span class="hljs-title class_">VueRouter</span>.<span class="hljs-property">install</span> = install;
</code></pre>
<p>下面，我们可以简单实现一下 Router-link 组件与 Router-view 组件，来做一个简单的测试。（接下来讲解如下内容）</p>
<p>components 目录下的 view.js 文件。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-string">&quot;router-view&quot;</span>);
  },
};
</code></pre>
<p>以上是 Router-View 组件的基本功能，后面在继续完善。</p>
<p>link.js 文件的实现如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">to</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
    },
  },
  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {
    <span class="hljs-comment">//通过插槽获取`a`标签内的文本。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;a&quot;</span>, { <span class="hljs-attr">domProps</span>: { <span class="hljs-attr">href</span>: <span class="hljs-string">&quot;#&quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">to</span> } }, [<span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>]);
  },
};
</code></pre>
<p>在 install.js 文件中，导入上面的组件进行测试。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">View</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/view&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Link</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/link&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> _Vue = <span class="hljs-literal">null</span>; <span class="hljs-comment">//将其导出，在其它文件中也可以使用Vue实例，而不需要单独的引入Vue的js文件</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">install</span>(<span class="hljs-params">Vue</span>) {
  <span class="hljs-comment">//获取Vue构造函数</span>
  _Vue = <span class="hljs-title class_">Vue</span>;
  _Vue.<span class="hljs-title function_">mixin</span>({
    <span class="hljs-comment">//通过混入以后，所有的Vue实例中都会有beforeCreate方法</span>
    <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) {
      <span class="hljs-comment">//判断是否为Vue的实例，如果条件成立为Vue的实例，否则为其它对应的组件（因为在创建Vue实例的时候会传递选项）</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>) {
        <span class="hljs-comment">//通过查看源码发现，Vue的实例会挂在到当前的私有属性_routerRoot属性上</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span> = <span class="hljs-variable language_">this</span>;

        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>;
        <span class="hljs-comment">//调用index.js文件中定义的init方法</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-title function_">init</span>(<span class="hljs-variable language_">this</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">_routerRoot</span>;
      }
    },
  });
  <span class="hljs-comment">//完成组件的注册</span>
  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;RouterView&quot;</span>, <span class="hljs-title class_">View</span>);
  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&quot;RouterLink&quot;</span>, <span class="hljs-title class_">Link</span>);
}
</code></pre>
<p>在上面的代码中，导入组件，并且完成组件的注册。</p>
<p>下面，我们测试一下。</p>
<p>在 src 目录下，在 router.js 文件中导入自己定义的 VueRouter.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./my-Vue-router&quot;</span>;
</code></pre>
<h3><a id="解析路由规则" class="content__heading-anchor"></a>解析路由规则</h3>
<p>下面，我们要做的就是对所有的路由规则进行解析，将其解析到一个数组中。方便根据地址找到对应的组件。</p>
<p>在源码的 index.js 文件中，创建了 VueRouter 类，对应的构造方法中，有如下代码：</p>
<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">matcher</span> = <span class="hljs-title function_">createMatcher</span>(options.<span class="hljs-property">routes</span> || [], <span class="hljs-variable language_">this</span>);
</code></pre>
<p>createMatcher 方法是在 create-matcher.js 文件中创建的。</p>
<p>该方法返回的 matcher 就是一个匹配器，其中有两个成员，match,另外一个是 addRoutes</p>
<p>match:根据路由地址匹配相应的路由规则对象。</p>
<p>addRoutes 动态添加路由</p>
<p>首先在我们自己的 index.js 文件中添加如下的代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> install <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./install&quot;</span>;
<span class="hljs-keyword">import</span> createMatcher <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./create-matcher&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VueRouter</span> {
  <span class="hljs-comment">//在创建VueRouter对象的时候，会传递选项</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-comment">//获取routes选项，该选项中定义路由规则</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routes</span> = options.<span class="hljs-property">routes</span> || [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">matcher</span> = <span class="hljs-title function_">createMatcher</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_routes</span>);
  }
  <span class="hljs-comment">// 注册路由变化的事件。</span>
  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-comment">//init(Vue){}</span>
}
<span class="hljs-comment">//将install方法挂载到VueRouter上</span>
<span class="hljs-title class_">VueRouter</span>.<span class="hljs-property">install</span> = install;
</code></pre>
<p>在上面的代码中，导入了 createMatcher 方法。</p>
<p>并且在调用该方法的时候传递了路由规则。</p>
<p>create-matcher.js 文件的代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> createRouteMap <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./create-route-map&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createMatcher</span>(<span class="hljs-params">routes</span>) {
  <span class="hljs-keyword">const</span> { pathList, pathMap } = <span class="hljs-title function_">createRouteMap</span>(routes);
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">match</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addRoutes</span>(<span class="hljs-params">routes</span>) {
    <span class="hljs-title function_">createRouteMap</span>(routes, pathList, pathMap);
  }
  <span class="hljs-keyword">return</span> {
    match,
    addRoutes,
  };
}
</code></pre>
<p>下面，我们需要在 create-route-map.js 文件中实现 createRouteMap 这个方法。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRouteMap</span>(<span class="hljs-params">routes, oldPathList, oldPathMap</span>) {
  <span class="hljs-keyword">const</span> pathList = oldPathList || [];
  <span class="hljs-keyword">const</span> pathMap = oldPathMap || {};
  <span class="hljs-comment">//遍历所有的路由规则，进行解析。同时还要考虑children的形式，</span>
  <span class="hljs-comment">//所以这里需要使用递归的方式。</span>
  routes.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> {
    <span class="hljs-title function_">addRouteRecord</span>(route, pathList, pathMap);
  });

  <span class="hljs-keyword">return</span> {
    pathList,
    pathMap,
  };
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">addRouteRecord</span>(<span class="hljs-params">route, pathList, pathMap, parentRecord</span>) {
  <span class="hljs-comment">//从路由规则中获取path。</span>
  <span class="hljs-keyword">const</span> path = parentRecord ? <span class="hljs-string">`<span class="hljs-subst">${parentRecord.path}</span>/<span class="hljs-subst">${route.path}</span>`</span> : route.<span class="hljs-property">path</span>;
  <span class="hljs-comment">//构建记录</span>
  <span class="hljs-keyword">const</span> record = {
    path,
    <span class="hljs-attr">component</span>: route.<span class="hljs-property">component</span>,
    <span class="hljs-attr">parent</span>: parentRecord, <span class="hljs-comment">//如果是子路由的话，记录子路由对应的父record对象（该对象中有path,component）,相当于记录了父子关系</span>
  };
  <span class="hljs-comment">//如果已经有了path,相同的path直接跳过</span>
  <span class="hljs-keyword">if</span> (!pathMap[path]) {
    pathList.<span class="hljs-title function_">push</span>(path);
    pathMap[path] = record;
  }
  <span class="hljs-comment">//判断route中是否有子路由</span>
  <span class="hljs-keyword">if</span> (route.<span class="hljs-property">children</span>) {
    <span class="hljs-comment">//遍历子路由，把子路由添加到pathList与pathMap中。</span>
    route.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">childRoute</span>) =&gt;</span> {
      <span class="hljs-title function_">addRouteRecord</span>(childRoute, pathList, pathMap, record);
    });
  }
}
</code></pre>
<p>下面测试一下上面的代码。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> createRouteMap <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./create-route-map&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createMatcher</span>(<span class="hljs-params">routes</span>) {
  <span class="hljs-keyword">const</span> { pathList, pathMap } = <span class="hljs-title function_">createRouteMap</span>(routes);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;pathList==&quot;</span>, pathList);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;pathMap==&quot;</span>, pathMap);
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">match</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addRoutes</span>(<span class="hljs-params">routes</span>) {
    <span class="hljs-title function_">createRouteMap</span>(routes, pathList, pathMap);
  }
  <span class="hljs-keyword">return</span> {
    match,
    addRoutes,
  };
}
</code></pre>
<p>在上面的代码中，我们打印了 pathList 与 pathMap.</p>
<p>当然，现在在我们所定义的路由规则中，还没有添加 children,构建相应的子路由。下面重新修改一下。</p>
<p>在项目根目录下的 router.js 文件中，添加对应的子路由规则。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;Vue&quot;</span>;
<span class="hljs-comment">// import Router from &quot;Vue-router&quot;;</span>
<span class="hljs-comment">// import Router from &quot;./Vuerouter&quot;;</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./my-Vue-router&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Login</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Login.Vue&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Home.Vue&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/About.Vue&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Users</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/Users&quot;</span>;
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>);
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>({
  <span class="hljs-comment">// model: &quot;history&quot;,</span>
  <span class="hljs-attr">routes</span>: [
    { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span> },
    { <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Login</span> },
    {
      <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,
      <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>,
      <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;users&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Users</span> }],
    },
  ],
});
</code></pre>
<p>这时候可以查看对应的输出结果。</p>
<h3><a id="match-函数实现" class="content__heading-anchor"></a>match 函数实现</h3>
<p>在 create-matcher.js 文件中，我们实现了 createRouteMap 方法，同时还需要实现 match 方法。</p>
<p>match 方法的作用就是根据路由地址，匹配一个路由对象。其实就是从 pathMap 中根据路由地址，找出对应的路由记录。路由记录中记录了组件信息，找到以后就可以完成组件的创建，渲染了。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">path</span>) {
  <span class="hljs-keyword">const</span> record = pathMap[path];
  <span class="hljs-keyword">if</span> (record) {
    <span class="hljs-comment">//根据路由地址，创建route路由规则对象</span>
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRoute</span>(record, path);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRoute</span>(<span class="hljs-literal">null</span>, path);
}
</code></pre>
<p>在上面的代码中，我们调用 match 方法的时候，会传递过来一个路径，我们根据这个路径可以从 pathMap 中找到对应的路由记录信息(这块在上一小节已经创建完毕)，如果找到了，我们还需要做进一步的处理，为什么呢？因为，我们传递过来的路径有可能是子路径，这时不光要获取到对应的子路由信息，我们还需要去查找对应的父路由的信息。所以这里需要进一步的处理，关于这块的处理封装到了 createRoute 这个方法中，而该方法在其它位置还需要，所以我们定义到 util 这个目录下 import createRoute from &quot;./util/route&quot;;。</p>
<p>create-matcher.js 文件完整代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> createRouteMap <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./create-route-map&quot;</span>;
<span class="hljs-keyword">import</span> createRoute <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./util/route&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createMatcher</span>(<span class="hljs-params">routes</span>) {
  <span class="hljs-keyword">const</span> { pathList, pathMap } = <span class="hljs-title function_">createRouteMap</span>(routes);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;pathList==&quot;</span>, pathList);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;pathMap==&quot;</span>, pathMap);
  <span class="hljs-comment">//实现match方法</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">match</span>(<span class="hljs-params">path</span>) {
    <span class="hljs-keyword">const</span> record = pathMap[path];
    <span class="hljs-keyword">if</span> (record) {
      <span class="hljs-comment">//根据路由地址，创建route路由规则对象</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRoute</span>(record, path);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRoute</span>(<span class="hljs-literal">null</span>, path);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addRoutes</span>(<span class="hljs-params">routes</span>) {
    <span class="hljs-title function_">createRouteMap</span>(routes, pathList, pathMap);
  }
  <span class="hljs-keyword">return</span> {
    match,
    addRoutes,
  };
}
</code></pre>
<p>下面我们需要在 my-Vue-router 目录下面在创建一个 util 目录，在该目录下面创建 route.js 文件，该文件实现的代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRoute</span>(<span class="hljs-params">record, path</span>) {
  <span class="hljs-keyword">const</span> matched = [];

  <span class="hljs-keyword">while</span> (record) {
    matched.<span class="hljs-title function_">unshift</span>(record);
    record = record.<span class="hljs-property">parent</span>;
  }

  <span class="hljs-keyword">return</span> {
    path,
    matched,
  };
}
</code></pre>
<p>总结：match 这个方法的作用就是根据路径，创建出路由规则对象，而所谓的路由规则对象其实就是包含了路径以及对应的路由记录的信息(这里有可能包含了父路由以及子路由记录，这块内容存储到一个数组中)。</p>
<p>以后，我们就可以根据路径直接获取到包含了整个路由记录的这个数组，从而可以将对应的组件全部创建出来。</p>
<h3><a id="历史记录处理" class="content__heading-anchor"></a>历史记录处理</h3>
<p>关于路由有三种模式：hash 模式，html5 模式，abstract 模式（该模式与服务端渲染有关）</p>
<p>在这里我们实现 hash 模式的历史记录管理，不管是哪种模式，都有相同的内容，这里我们相同的内容定义到</p>
<p>父类中。</p>
<p>在该父类中主要有如下内容：</p>
<p>router 属性：路由对象（ViewRouter）</p>
<p>current 属性，记录当前路径对应的路由规则对象{path:'/',matched:[]},关于该对象，我们在前面已经处理完了。也就是在 createRoute 方法中返回的内容。</p>
<p>transitionTo()</p>
<p>跳转到指定的路径，根据当前路径获取匹配的路由规则对象 route，然后更新视图。</p>
<p>在 my-Vue-router 目录下的，history 目录下的 base.js 文件，编写如下的代码：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> createRoute <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util/route&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">History</span> {
  <span class="hljs-comment">// router路由对象ViewRouter</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">router</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = router;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-title function_">createRoute</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;/&quot;</span>);
  }

  <span class="hljs-title function_">transitionTo</span>(<span class="hljs-params">path, onComplete</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">matcher</span>.<span class="hljs-title function_">match</span>(path);
    <span class="hljs-comment">//该回调函数在调用transitionTo方法的时候，会传递过来。</span>
    onComplete &amp;&amp; <span class="hljs-title function_">onComplete</span>();
  }
}
</code></pre>
<p>父类已经实现了，下面实现对应的子类。也就是 HashHistory</p>
<p>HashHistory 继承 History, 同时要确保首次访问的地址为#/.</p>
<p>在 History 中还需要定义两个方法，第一个方法为：getCurrentLocation( ) 获取当前的路由地址(# 后面的部分)</p>
<p>setUpListener( )方法监听路由地址改变的事件（hashchange）。</p>
<p>在 history 目录下的 hash.js 文件中的代码实现如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">History</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./base&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashHistory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">History</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">router</span>) {
    <span class="hljs-comment">//将路由对象传递给父类的构造函数</span>
    <span class="hljs-variable language_">super</span>(router);
    <span class="hljs-comment">//确保 首次 访问地址加上 #/  （//由于没有添加this,为普通方法）</span>
    <span class="hljs-title function_">ensureSlash</span>();
  }
  <span class="hljs-comment">// 获取当前的路由地址 （# 后面的部分）所以这里需要去除#</span>
  <span class="hljs-title function_">getCurrentLocation</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);
  }
  <span class="hljs-comment">// 监听hashchange事件</span>
  <span class="hljs-comment">//也就是监听路由地址的变化</span>
  <span class="hljs-title function_">setUpListener</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;hashchange&quot;</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-comment">//当路由地址发生变化后，跳转到新的路由地址。</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">transitionTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getCurrentLocation</span>());
    });
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureSlash</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">//判断当前是否有hash</span>
  <span class="hljs-comment">// 如果单击的是链接，肯定会有hash</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>) {
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span> = <span class="hljs-string">&quot;/&quot;</span>;
}
</code></pre>
<h3><a id="init-方法实现" class="content__heading-anchor"></a>Init 方法实现</h3>
<p>我们知道当创建 VueRouter 的时候，需要可以传递 mode，来指定路由的形式，例如是 hash 模式还是 html5 模式等。</p>
<p>所以这里需要根据指定的 mode 的模式，来选择 history 目录中中不同 js 来处理。</p>
<p>所以在 my-Vue-router 目录中的 index.js 文件中，做如下的修改：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> install <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./install&quot;</span>;
<span class="hljs-keyword">import</span> createMatcher <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./create-matcher&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">HashHistory</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./history/hash&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">HTML5History</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./history/html5&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VueRouter</span> {
  <span class="hljs-comment">//在创建VueRouter对象的时候，会传递选项</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">options</span>) {
    <span class="hljs-comment">//获取routes选项，该选项中定义路由规则</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routes</span> = options.<span class="hljs-property">routes</span> || [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">matcher</span> = <span class="hljs-title function_">createMatcher</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_routes</span>);
    <span class="hljs-comment">//获取传递过来的选项中的mode,mode中决定了用户设置的路由的形式。</span>
    <span class="hljs-comment">//这里给VueRouter添加了mode属性</span>
    <span class="hljs-keyword">const</span> mode = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = options.<span class="hljs-property">mode</span> || <span class="hljs-string">&quot;hash&quot;</span>);
    <span class="hljs-keyword">switch</span> (mode) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hash&quot;</span>:
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashHistory</span>(<span class="hljs-variable language_">this</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;history&quot;</span>:
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTML5History</span>(<span class="hljs-variable language_">this</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;mode error&quot;</span>);
    }
  }
  <span class="hljs-comment">// 注册路由变化的事件。</span>
  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {}
  <span class="hljs-comment">//init(Vue){}</span>
}
<span class="hljs-comment">//将install方法挂载到VueRouter上</span>
<span class="hljs-title class_">VueRouter</span>.<span class="hljs-property">install</span> = install;
</code></pre>
<p>首先导入 HashHistory 与 HTML5History.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">HashHistory</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./history/hash&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">HTML5History</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./history/html5&quot;</span>;
</code></pre>
<p>下面获取选项中的 mode,如果在创建 VueRouter 对象的时候，没有指定 mode,那么默认的值为 hash.</p>
<p>下面就对获取到的 mode 进行判断，根据 mode 的不同的值，创建不同的 history 的实例。</p>
<pre><code class="language-javascript"><span class="hljs-comment">//获取传递过来的选项中的mode,mode中决定了用户设置的路由的形式。</span>
<span class="hljs-comment">//这里给VueRouter添加了mode属性</span>
<span class="hljs-keyword">const</span> mode = (<span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = options.<span class="hljs-property">mode</span> || <span class="hljs-string">&quot;hash&quot;</span>);
<span class="hljs-keyword">switch</span> (mode) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hash&quot;</span>:
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashHistory</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;history&quot;</span>:
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTML5History</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-attr">default</span>:
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;mode error&quot;</span>);
}
</code></pre>
<p>同时 html5.js 文件，添加了基本的代码</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">History</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./base&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HTML5History</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">History</span> {}
</code></pre>
<p>关于 Html5 的形式这里不在实现了。</p>
<p>下面完善一下 init 方法</p>
<pre><code class="language-javascript"> <span class="hljs-comment">// 注册路由变化的事件。</span>
  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {}

  <span class="hljs-comment">// 注册路由变化的事件(初始化事件监听器，监听路由地址的变化)。</span>
  <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> history = <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setUpListener</span> = (<span class="hljs-params"></span>) =&gt; {
      history.<span class="hljs-title function_">setUpListener</span>();
    };
    history.<span class="hljs-title function_">transitionTo</span>(
      history.<span class="hljs-title function_">getCurrentLocation</span>(),
      <span class="hljs-comment">//如果直接history.setUpListener</span>
      <span class="hljs-comment">// 这样的话setUpListener里面的this会有问题。</span>
      setUpListener
    );
  }
</code></pre>
<p>在这里，调用了 transitionTo 方法的原因是，在 hash.js 文件中的 ensureSlash 方法中，完成了一次地址的修改，所以这里需要跳转一次。</p>
<p>同时完成了 hashchange 事件的绑定（路由变化的事件）。</p>
<p>下面可以进行测试一下，在 base.js 文件中的 transitionTo 方法中，打印出 current 属性的值。</p>
<pre><code class="language-javascript">  <span class="hljs-title function_">transitionTo</span>(<span class="hljs-params">path, onComplete</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">matcher</span>.<span class="hljs-title function_">match</span>(path);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;current===&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>);
 <span class="hljs-comment">//该回调函数在调用transitionTo方法的时候，会传递过来。</span>
    onComplete &amp;&amp; <span class="hljs-title function_">onComplete</span>();
  }
</code></pre>
<p>下面，在浏览器的地址栏中输入了不同的 URL 地址后，在控制台上呈现出了不同的路由规则对象，也就是路由记录信息。</p>
<p>地址为子路由的地址，最终也输出了对应的父路由的记录信息。</p>
<p>后期就可以获取具体的组件来进行渲染。</p>
<h3><a id="设置响应式的_route" class="content__heading-anchor"></a>设置响应式的_route</h3>
<p>下面我们要做的就是渲染组件。</p>
<p>这里我们先创建一个与路由有关的响应式属性，当路由地址发生变化了，对应的该属性也要发生变化，从而完成页面的重新渲染。</p>
<p>在 install.js 文件中添加如下的代码：</p>
<pre><code class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">util</span>.<span class="hljs-title function_">defineReactive</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;_route&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-property">history</span>.<span class="hljs-property">current</span>);
</code></pre>
<p>以上完成了响应式属性的创建，但是要注意的是 defineReactive 方法为 Vue 的内部方法，不建议平时通过该方法来创建响应式对象。</p>
<pre><code class="language-javascript">  <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) {
      <span class="hljs-comment">//判断是否为Vue的实例，如果条件成立为Vue的实例，否则为其它对应的组件（因为在创建Vue实例的时候会传递选项）</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>) {
        <span class="hljs-comment">//通过查看源码发现，Vue的实例会挂在到当前的私有属性_routerRoot属性上</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span> = <span class="hljs-variable language_">this</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$options</span>.<span class="hljs-property">router</span>;
        <span class="hljs-comment">//调用index.js文件中定义的init方法</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-title function_">init</span>(<span class="hljs-variable language_">this</span>);


        <span class="hljs-comment">//在Vue的实例上创建一个响应式的属性`_route`.</span>
        <span class="hljs-title class_">Vue</span>.<span class="hljs-property">util</span>.<span class="hljs-title function_">defineReactive</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;_route&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-property">history</span>.<span class="hljs-property">current</span>);
      }
</code></pre>
<p>下面要考虑的就是当路由地址发生了变化后，需要修改_route 属性的值。</p>
<p>在哪完成_route 属性值的修改呢？</p>
<p>在 base.js 文件中，因为在该文件中定义了 transitionTo 方法，而该方法就是用来完成地址的跳转，同时完成组件的渲染。</p>
<p>base.js 文件修改后的代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> createRoute <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util/route&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">History</span> {
  <span class="hljs-comment">// router路由对象ViewRouter</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">router</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = router;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-title function_">createRoute</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;/&quot;</span>);
    <span class="hljs-comment">//这个回调函数是在hashhistory中赋值，作用是更改Vue实例上的_route，_route的值发生变化，视图会进行刷新操作</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">//给cb赋值</span>
  <span class="hljs-title function_">listen</span>(<span class="hljs-params">cb</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;
  }

  <span class="hljs-title function_">transitionTo</span>(<span class="hljs-params">path, onComplete</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">matcher</span>.<span class="hljs-title function_">match</span>(path);
    <span class="hljs-comment">// 调用cb</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>);
    <span class="hljs-comment">// console.log(&quot;current===&quot;, this.current);</span>

    <span class="hljs-comment">//该回调函数在调用transitionTo方法的时候，会传递过来。</span>
    onComplete &amp;&amp; <span class="hljs-title function_">onComplete</span>();
  }
}
</code></pre>
<p>在 History 中的构造方法中初始化 cb 函数。</p>
<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = <span class="hljs-literal">null</span>;
</code></pre>
<p>定义 listen 方法给 cb 函数赋值。</p>
<pre><code class="language-javascript"><span class="hljs-comment">//给cb赋值</span>
  <span class="hljs-title function_">listen</span>(<span class="hljs-params">cb</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;
  }
</code></pre>
<p>在 transitionTo 方法中调用 cb 函数，同时传递获取到的当前的路由规则对象也就是路由记录信息。</p>
<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>);
</code></pre>
<p>在什么地方调用 listen 方法呢？</p>
<p>在 index.js 文件中的 init 方法中完成 listen 方法的调用。</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 注册路由变化的事件(初始化事件监听器，监听路由地址的变化)。</span>
  <span class="hljs-title function_">init</span>(<span class="hljs-params">app</span>) {
    <span class="hljs-keyword">const</span> history = <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setUpListener</span> = (<span class="hljs-params"></span>) =&gt; {
      history.<span class="hljs-title function_">setUpListener</span>();
    };
    history.<span class="hljs-title function_">transitionTo</span>(
      history.<span class="hljs-title function_">getCurrentLocation</span>(),
      <span class="hljs-comment">//如果直接history.setUpListener</span>
      <span class="hljs-comment">// 这样的话setUpListener里面的this会有问题。</span>
      setUpListener
    );
    <span class="hljs-comment">//调用父类的中的listen方法</span>
    history.<span class="hljs-title function_">listen</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> {
      app.<span class="hljs-property">_route</span> = route;
    });
  }
</code></pre>
<p>在上面的代码中调用了父类中的 listen 方法，然后将箭头函数传递到了 listen 中。</p>
<p>这时候，在 transitionTo 方法中调用 cb，也就是调用箭头函数，这时传递过来的参数 route,为当前更改后的路由规则信息，交给了 app 中的_route 属性。</p>
<p>app 这个参数其实就是 Vue 的实例，因为在 install.js 文件中调用了 init 方法，并且传递的就是 Vue 的实例。</p>
<p>这样就完成了对 Vue 实例上的响应式属性_route 值的修改，从而会更新组件。</p>
<h3><a id="routerouter-创建" class="content__heading-anchor"></a><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">route/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span>router 创建</h3>
<p>创建<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>与</mtext></mrow><annotation encoding="application/x-tex">route与</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">与</span></span></span></span>router 的目的是能够在所有的 Vue 实例(组件)中，可以获取到。</p>
<p>$route 是路由规则对象，包含了 path,component 等内容</p>
<p>$router 为路由对象（ViewRouter 对象）。</p>
<p>通过查看源码(install.js)可以发现，其实就是将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext>与</mtext></mrow><annotation encoding="application/x-tex">router 与</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord cjk_fallback">与</span></span></span></span>route 挂载到了 Vue 的原型上。</p>
<p>所以可以直接将源码内容复制过来就可以了。</p>
<pre><code class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;$router&quot;</span>, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span>.<span class="hljs-property">_router</span>;
  },
});

<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;$route&quot;</span>, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span>.<span class="hljs-property">_route</span>;
  },
});
</code></pre>
<p>通过上面的代码，可以看到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>与</mtext></mrow><annotation encoding="application/x-tex">route与</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">与</span></span></span></span>router 都是只读的，因为对应的值，在前面已经设置完毕，这里只是获取。</p>
<p>$router 是通过_routerRoot 来获取。</p>
<p>$route 是通过_routerRoot._route 来获取。</p>
<pre><code class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">util</span>.<span class="hljs-title function_">defineReactive</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;_route&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-property">history</span>.<span class="hljs-property">current</span>);
</code></pre>
<p>在 Vue 对象上创建了_route 属性，该属性的值为路由规则内容</p>
<h3><a id="router-view-创建" class="content__heading-anchor"></a>Router-View 创建</h3>
<p>router-view 就是一个占位符，会用具体的组件来替换该占位符。</p>
<p>router-view 的创建过程如下：</p>
<p>获取当前组件的$route 路由规则对象<br>
找到路由规则对象里面的 matched 匹配的 record(里面有 component)<br>
如果是/about ,matched 匹配到一个 record，直接渲染对应的组件<br>
如果是/about/users,matched 匹配到两个 record（第一个是父组件，第二个是子组件）<br>
my-Vue-router/components 目录下的 view.js 代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {
    <span class="hljs-comment">//获取当前匹配的路由规则对象</span>
    <span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>;
    <span class="hljs-comment">//获取路由记录对象.只有一个内容，所以获取的是`matched`中的第一项。</span>
    <span class="hljs-keyword">const</span> record = route.<span class="hljs-property">matched</span>[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (!record) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>();
    }
    <span class="hljs-comment">//获取记录中对应的组件</span>
    <span class="hljs-keyword">const</span> component = record.<span class="hljs-property">component</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(component);
  },
};
</code></pre>
<p>以上的代码处理的是没有子路由的情况。</p>
<p>下面，看一下子路由情况的处理。</p>
<p>当然在编写子路由的处理代码之前，我们先把案例中的路由完善一下。</p>
<p>在 src 目录下的 App.Vue 这个组件中，添加一个“关于”的链接。</p>
<pre><code class="language-javascript">&lt;template&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>对应在 About 这个组件中，完成子路由应用</p>
<pre><code class="language-javascript">&lt;template&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    关于组件
    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about/users&quot;</span>&gt;</span>用户<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

</code></pre>
<p>下面完善一下对子路由的处理。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {
    <span class="hljs-comment">//获取当前匹配的路由规则对象</span>
    <span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>;
    <span class="hljs-keyword">let</span> depth = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//记录当前组件为RouterView</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routerView</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">let</span> parent = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>;
    <span class="hljs-keyword">while</span> (parent) {
      <span class="hljs-keyword">if</span> (parent.<span class="hljs-property">routerView</span>) {
        depth++;
      }
      parent = parent.<span class="hljs-property">$parent</span>;
    }
    <span class="hljs-comment">//获取路由记录对象.</span>
    <span class="hljs-comment">// 如果是子路由，例如：子路由/about/users</span>
    <span class="hljs-comment">//子路由是有两部分内容，matched[0]:是父组件内容，matched[1]是子组件内容</span>
    <span class="hljs-keyword">const</span> record = route.<span class="hljs-property">matched</span>[depth];
    <span class="hljs-keyword">if</span> (!record) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>();
    }
    <span class="hljs-comment">//获取记录中对应的组件</span>
    <span class="hljs-keyword">const</span> component = record.<span class="hljs-property">component</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(component);
  },
};
</code></pre>
<p>假如，现在我们在浏览器的地址栏中输入了：<code>http://localhost:8080/#/about</code> 地址，</p>
<p>是没有父组件，那么 depth 属性的值为 0，这时候获取的第一个组件然后进行渲染。</p>
<p>如果地址栏的内容为：<code>http://localhost:8080/#/about/users</code>这时候有子组件。对应的获取对应的父组件内容，开始进行循环。</p>
<p>的属性_route.</p>
<pre><code class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">util</span>.<span class="hljs-title function_">defineReactive</span>(<span class="hljs-variable language_">this</span>, “_route”, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-property">history</span>.<span class="hljs-property">current</span>);
</code></pre>
<p>下面要考虑的就是当路由地址发生了变化后，需要修改<code>_route</code>属性的值。</p>
<p>在哪完成<code>_route</code>属性值的修改呢？</p>
<p>在<code>base.js</code>文件中，因为在该文件中定义了<code>transitionTo</code>方法，而该方法就是用来完成地址的跳转，同时完成组件的渲染。</p>
<p><code>base.js</code>文件修改后的代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> createRoute <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../util/route&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">History</span> {
  <span class="hljs-comment">// router路由对象ViewRouter</span>
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">router</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span> = router;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-title function_">createRoute</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;/&quot;</span>);
    <span class="hljs-comment">//这个回调函数是在hashhistory中赋值，作用是更改Vue实例上的_route，_route的值发生变化，视图会进行刷新操作</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">//给cb赋值</span>
  <span class="hljs-title function_">listen</span>(<span class="hljs-params">cb</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;
  }

  <span class="hljs-title function_">transitionTo</span>(<span class="hljs-params">path, onComplete</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">router</span>.<span class="hljs-property">matcher</span>.<span class="hljs-title function_">match</span>(path);
    <span class="hljs-comment">// 调用cb</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>);
    <span class="hljs-comment">// console.log(&quot;current===&quot;, this.current);</span>

    <span class="hljs-comment">//该回调函数在调用transitionTo方法的时候，会传递过来。</span>
    onComplete &amp;&amp; <span class="hljs-title function_">onComplete</span>();
  }
}
</code></pre>
<p>在 History 中的构造方法中初始化 cb 函数。</p>
<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = <span class="hljs-literal">null</span>;
</code></pre>
<p>定义 listen 方法给 cb 函数赋值。</p>
<pre><code class="language-javascript"><span class="hljs-comment">//给cb赋值</span>
  <span class="hljs-title function_">listen</span>(<span class="hljs-params">cb</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;
  }
</code></pre>
<p>在 transitionTo 方法中调用 cb 函数，同时传递获取到的当前的路由规则对象也就是路由记录信息。</p>
<pre><code class="language-javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span>);
</code></pre>
<p>在什么地方调用 listen 方法呢？</p>
<p>在 index.js 文件中的 init 方法中完成 listen 方法的调用。</p>
<pre><code class="language-javascript"><span class="hljs-comment">// 注册路由变化的事件(初始化事件监听器，监听路由地址的变化)。</span>
  <span class="hljs-title function_">init</span>(<span class="hljs-params">app</span>) {
    <span class="hljs-keyword">const</span> history = <span class="hljs-variable language_">this</span>.<span class="hljs-property">history</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setUpListener</span> = (<span class="hljs-params"></span>) =&gt; {
      history.<span class="hljs-title function_">setUpListener</span>();
    };
    history.<span class="hljs-title function_">transitionTo</span>(
      history.<span class="hljs-title function_">getCurrentLocation</span>(),
      <span class="hljs-comment">//如果直接history.setUpListener</span>
      <span class="hljs-comment">// 这样的话setUpListener里面的this会有问题。</span>
      setUpListener
    );
    <span class="hljs-comment">//调用父类的中的listen方法</span>
    history.<span class="hljs-title function_">listen</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> {
      app.<span class="hljs-property">_route</span> = route;
    });
  }
</code></pre>
<p>在上面的代码中调用了父类中的 listen 方法，然后将箭头函数传递到了 listen 中。</p>
<p>这时候，在 transitionTo 方法中调用 cb，也就是调用箭头函数，这时传递过来的参数 route,为当前更改后的路由规则信息，交给了 app 中的_route 属性。</p>
<p>app 这个参数其实就是 Vue 的实例，因为在 install.js 文件中调用了 init 方法，并且传递的就是 Vue 的实例。</p>
<p>这样就完成了对 Vue 实例上的响应式属性_route 值的修改，从而会更新组件。</p>
<h3><a id="routerouter-创建-1" class="content__heading-anchor"></a><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">route/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord">/</span></span></span></span>router 创建</h3>
<p>创建<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>与</mtext></mrow><annotation encoding="application/x-tex">route与</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">与</span></span></span></span>router 的目的是能够在所有的 Vue 实例(组件)中，可以获取到。</p>
<p>$route 是路由规则对象，包含了 path,component 等内容</p>
<p>$router 为路由对象（ViewRouter 对象）。</p>
<p>通过查看源码(install.js)可以发现，其实就是将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mi>r</mi><mtext>与</mtext></mrow><annotation encoding="application/x-tex">router 与</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord cjk_fallback">与</span></span></span></span>route 挂载到了 Vue 的原型上。</p>
<p>所以可以直接将源码内容复制过来就可以了。</p>
<pre><code class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;$router&quot;</span>, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span>.<span class="hljs-property">_router</span>;
  },
});

<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&quot;$route&quot;</span>, {
  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_routerRoot</span>.<span class="hljs-property">_route</span>;
  },
});
</code></pre>
<p>通过上面的代码，可以看到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>u</mi><mi>t</mi><mi>e</mi><mtext>与</mtext></mrow><annotation encoding="application/x-tex">route与</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord cjk_fallback">与</span></span></span></span>router 都是只读的，因为对应的值，在前面已经设置完毕，这里只是获取。</p>
<p>$router 是通过_routerRoot 来获取。</p>
<p>$route 是通过_routerRoot._route 来获取。</p>
<pre><code class="language-javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">util</span>.<span class="hljs-title function_">defineReactive</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;_route&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_router</span>.<span class="hljs-property">history</span>.<span class="hljs-property">current</span>);
</code></pre>
<p>在 Vue 对象上创建了_route 属性，该属性的值为路由规则内容</p>
<h3><a id="router-view-创建-1" class="content__heading-anchor"></a>Router-View 创建</h3>
<p>router-view 就是一个占位符，会用具体的组件来替换该占位符。</p>
<p>router-view 的创建过程如下：</p>
<p>获取当前组件的$route 路由规则对象<br>
找到路由规则对象里面的 matched 匹配的 record(里面有 component)<br>
如果是/about ,matched 匹配到一个 record，直接渲染对应的组件<br>
如果是/about/users,matched 匹配到两个 record（第一个是父组件，第二个是子组件）<br>
my-Vue-router/components 目录下的 view.js 代码如下：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {
    <span class="hljs-comment">//获取当前匹配的路由规则对象</span>
    <span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>;
    <span class="hljs-comment">//获取路由记录对象.只有一个内容，所以获取的是`matched`中的第一项。</span>
    <span class="hljs-keyword">const</span> record = route.<span class="hljs-property">matched</span>[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (!record) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>();
    }
    <span class="hljs-comment">//获取记录中对应的组件</span>
    <span class="hljs-keyword">const</span> component = record.<span class="hljs-property">component</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(component);
  },
};
</code></pre>
<p>以上的代码处理的是没有子路由的情况。</p>
<p>下面，看一下子路由情况的处理。</p>
<p>当然在编写子路由的处理代码之前，我们先把案例中的路由完善一下。</p>
<p>在 src 目录下的 App.Vue 这个组件中，添加一个“关于”的链接。</p>
<pre><code class="language-javascript">&lt;template&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/login&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<p>对应在 About 这个组件中，完成子路由应用</p>
<pre><code class="language-javascript">&lt;template&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    关于组件
    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about/users&quot;</span>&gt;</span>用户<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;/template&gt;

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
</code></pre>
<p>下面完善一下对子路由的处理。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) {
    <span class="hljs-comment">//获取当前匹配的路由规则对象</span>
    <span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>;
    <span class="hljs-keyword">let</span> depth = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//记录当前组件为RouterView</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">routerView</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">let</span> parent = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>;
    <span class="hljs-keyword">while</span> (parent) {
      <span class="hljs-keyword">if</span> (parent.<span class="hljs-property">routerView</span>) {
        depth++;
      }
      parent = parent.<span class="hljs-property">$parent</span>;
    }
    <span class="hljs-comment">//获取路由记录对象.</span>
    <span class="hljs-comment">// 如果是子路由，例如：子路由/about/users</span>
    <span class="hljs-comment">//子路由是有两部分内容，matched[0]:是父组件内容，matched[1]是子组件内容</span>
    <span class="hljs-keyword">const</span> record = route.<span class="hljs-property">matched</span>[depth];
    <span class="hljs-keyword">if</span> (!record) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>();
    }
    <span class="hljs-comment">//获取记录中对应的组件</span>
    <span class="hljs-keyword">const</span> component = record.<span class="hljs-property">component</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(component);
  },
};
</code></pre>
<p>假如，现在我们在浏览器的地址栏中输入了：<code>http://localhost:8080/#/about</code> 地址，</p>
<p>是没有父组件，那么 depth 属性的值为 0，这时候获取的第一个组件然后进行渲染。</p>
<p>如果地址栏的内容为：<code>http://localhost:8080/#/about/users</code> 这时候有子组件。对应的获取对应的父组件内容，开始进行循环。</p>
<p>在循环的时候，做了一个判断，判断的条件就是当前的父组件必须为:RouterView 组件（子组件中 router-view 与父组件中的 router-view 构成了父子关系），才让 depth 加 1，然后取出子组件进行渲染。</p>
 </article> </section> </main>  <footer class="footer"> <hr class="footer__divide"> <div class="footer__row"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">9Sky 九天</a> </p> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv>  项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> </footer> </body></html> 