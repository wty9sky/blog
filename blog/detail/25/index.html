<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>Rust学习：Package&amp;Module</title><link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico"><link rel="sitemap" href="/sitemap-index.xml"><title>Rust学习：Package&Module</title><link rel="canonical" href="https://wty9sky.github.io/blog/detail/25/"><meta name="description" content="Rust学习：Package&#38;Module"><meta name="robots" content="index, follow"><meta property="og:title" content="Rust学习：Package&#38;Module"><meta property="og:type" content="article"><meta property="og:image" content="/og.svg"><meta property="og:url" content="https://wty9sky.github.io/blog/detail/25/"><meta property="og:locale" content="zh_CN"><meta property="og:locale:alternate" content="zh_TW"><meta property="og:locale:alternate" content="en_US"><meta property="og:site_name" content="9Sky 九天"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/avatar.png"><meta name="generator" content="Astro v4.16.7"><meta name="keywords" content="详情"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.zJyvFudD.css">
<link rel="stylesheet" href="/_astro/about.D3zQv4Ly.css"><script type="module" src="/_astro/hoisted.HO6_Fzad.js"></script></head> <body> <header class="header"> <h5 class="header__heading"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
Rust学习：Package&amp;Module </span> </h5> </header> <div id="navbar-sentinal"></div> <nav class="navbar" id="navbar-wrapper"> <div class="navbar__content"> <h5 class="navbar__path"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
Rust学习：Package&amp;Module </span> </h5> <div class="navbar__menu"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("#navbar-sentinal");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersectin && e[0].boundingClientRect.top <= 0) {
        headerEl.classList.add("navbar--sticked");
      } else {
        headerEl.classList.remove("navbar--sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>  <main class="page"> <section class="page__section page__section--at-top"> <!-- {
        article.cover && (
          <a href={article.cover} data-fancybox data-caption={article.title}>
            <img
              src={article.cover}
              alt={article.title}
              title={article.title}
              class="page__cover mb-8"
            />
          </a>
        )
      } --> <h1 class="page__heading">Rust学习：Package&amp;Module</h1> <p class="page__meta"> <i class="ri-calendar-line"></i> <span>2024 年 5 月 18 日 02:46</span> </p> <hr class="page__divide"> <article class="content"> <h2><a id="文章目录" class="content__heading-anchor"></a>文章目录</h2>
<ul>
<li><a href="#packagecratemodule">Package，Crate，Module</a>
<ul>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87">代码组织</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F">模块系统</a>
<ul>
<li><a href="#package-%E4%B8%8E-crate">Package 与 Crate</a></li>
<li><a href="#cargo-%E7%9A%84%E6%83%AF%E4%BE%8B">Cargo 的惯例</a></li>
<li><a href="#%E5%AE%9A%E4%B9%89-module-%E6%9D%A5%E6%8E%A7%E5%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%A7%81%E6%9C%89%E6%80%A7">定义 Module 来控制作用域和私有性</a></li>
<li><a href="#%E8%B7%AF%E5%BE%84-path">路径 PATH</a></li>
<li><a href="#use-%E5%85%B3%E9%94%AE%E5%AD%97">use 关键字</a></li>
<li><a href="#as">as</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8C%85">使用外部包</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E8%B7%AF%E5%BE%84%E6%B8%85%E7%90%86%E5%A4%A7%E9%87%8F%E7%9A%84-use-%E8%AF%AD%E5%8F%A5">使用嵌套路径清理大量的 use 语句</a></li>
<li><a href="#%E9%80%9A%E9%85%8D%E7%AC%A6">通配符</a></li>
<li><a href="#%E5%B0%86%E6%A8%A1%E5%9D%97%E5%86%85%E5%AE%B9%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6">将模块内容移动到其他文件</a></li>
</ul></li>
</ul></li>
</ul>
<h1><a id="packagecratemodule" class="content__heading-anchor"></a>Package，Crate，Module</h1>
<h2><a id="代码组织" class="content__heading-anchor"></a>代码组织</h2>
<ul>
<li>目前为止我们都是在一个文件中编写的，主要是为了方便学习 Rust 语言的语法和概念。</li>
<li>对于一个工程来讲，组织代码是十分重要的。</li>
<li>通过对相关功能进行分组和划分不同功能的代码，你可以清楚在哪里可以找到实现了特定功能的代码，以及在哪里可以改变一个功能的工作方式。</li>
</ul>
<h2><a id="模块系统" class="content__heading-anchor"></a>模块系统</h2>
<ul>
<li>Package（包）：
<ul>
<li>Cargo 的特性，让你构建、测试、共享 Crate</li>
</ul></li>
<li>Crate（箱）：
<ul>
<li>一个模块树（当你要编译时，你要编译的那个文件就叫 crate），它可以编译生成一个 二进制文件 或 多个库文件</li>
</ul></li>
<li>Module（模块）、use：
<ul>
<li>让你控制代码的组织、作用域、私有路径</li>
</ul></li>
<li>Path（路径）：
<ul>
<li>为 struct、function、module 等项命名的方式</li>
</ul></li>
</ul>
<h3><a id="package-与-crate" class="content__heading-anchor"></a>Package 与 Crate</h3>
<ul>
<li>Crate 的类型有两种：
<ul>
<li>binary crate（二进制）编译后产生二进制文件的源文件就叫 binary crate</li>
<li>library crate（库）编译后产生二进制文件的源文件就叫 library crate</li>
</ul></li>
<li>Crate Root（Crate 的根）：是源代码文件</li>
</ul>
<p>Rust 编译器从这里开始，如果里面含有 mod 声明，那么模块文件的内容将在编译之前被插入 crate 文件的相应声明处</p>
<ul>
<li>一个 Package：
<ul>
<li>包含一个 Cargo.toml，它描述了如何构建这些 Crates</li>
<li>只能包含 0-1 个 library crate</li>
<li>可以包含任意数量的 binary crate</li>
<li>但至少包含一个 crate （library 或 binary）</li>
</ul></li>
</ul>
<h3><a id="cargo-的惯例" class="content__heading-anchor"></a>Cargo 的惯例</h3>
<p>一个例子：</p>
<p>我们创建一个新的项目（一个项目就是一个包）</p>
<p>cargo new my-project1<br>
官方文档：src/main.rs ，是一个与包同名的 binary crate 的 crate 根</p>
<p>解释：src/main.rs 被 Cargo 传递给编译器 rustc 编译后，产生与包同名的二进制文件</p>
<p>cargo new --lib my-project2<br>
官方文档：src/lib.rs，是与包同名的 library crate 的 crate 根</p>
<p>解释：src/lib.rs 被 Cargo 传递给编译器 rustc 编译后，产生与包同名的库文件</p>
<p>Cargo 会默认把这个文件作为根</p>
<p>如果一个 Package 同时包含 src/main.rs 和 src/lib.rs<br>
那就说明它有一个 binary crate 一个 library crate<br>
一个 Package 有多个 binary crate 的情况下<br>
文件要放在 src/bin 下<br>
每个文件都是单独的 binary crate</p>
<h3><a id="定义-module-来控制作用域和私有性" class="content__heading-anchor"></a>定义 Module 来控制作用域和私有性</h3>
<p>Module<br>
在一个 crate 内，将代码进行分组<br>
增加可读性，易于复用<br>
public private<br>
建立 Mudule：<br>
cargo new --lib module<br>
在 lib.rs 文件中写入 module</p>
<p>我们定义一个模块，是以 mod 关键字为起始，然后指定模块的名字（本例中叫做 front_of_house），并且用花括号包围模块的主体。在模块内，我们还可以定义其他的模块，就像本例中的 hosting 和 serving 模块。模块还可以保存一些定义的其他项，比如结构体、枚举、常量、特性、或者函数。</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house {
<span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {}

        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">seat_at_table</span>() {}
    }

    <span class="hljs-keyword">mod</span> serving {
        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_order</span>() {}

        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">server_order</span>() {}

        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_payment</span>() {}
    }

}
</code></pre>
<p>在前面我们提到了，src/main.rs 和 src/lib.rs 叫做 crate 根。之所以这样叫它们的原因是，这两个文件的内容都是一个从名为 crate 的模块作为根的 crate 模块结构，称为 模块树（module tree）。这个就是 lib.rs 的模块树</p>
<p>crate<br>
└── front_of_house<br>
├── hosting<br>
│ ├── add_to_waitlist<br>
│ └── seat_at_table<br>
└── serving<br>
├── take_order<br>
├── serve_order<br>
└── take_payment</p>
<h3><a id="路径-path" class="content__heading-anchor"></a>路径 PATH</h3>
<p>为了在 Rust 的模块中找到某个条目，需要使用路径<br>
路径的两周形式<br>
绝对路径：从 crate root 开始，使用 crate 名 或 字面值 crate<br>
相对路径：从当前模块开始，使用 self 、super 或当前模块的标识符<br>
路径至少由一个标识符组成，标识符之间使用 ::<br>
如果定义的部分和使用的部分总是一起移动，用相对路径，可以独立拆解出来，用绝对路径</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house {
<span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;1111&quot;</span>);
}
}
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
crate::front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<span class="hljs-comment">//绝对路径</span>

    front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<span class="hljs-comment">//相对路径</span>

}
</code></pre>
<p>会报错 module hosting is private</p>
<p>为什么 crate 和 front_of_house 不报错而是从 hosting 开始呢?</p>
<p>因为 fn main 和 crate, front_of_house 一样都是根节点，根节点之间访问无论私有公有</p>
<p>能放入 mod 内部中的一切都是默认是私有的，要把改为共有 pub</p>
<p>额外知识点<br>
父级模块无法访问子模块中的条目<br>
子模块可以使用所有祖先模块中的条目<br>
公有是 pub</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {
<span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;1111&quot;</span>);
}
}
}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
crate::front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();

    front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();

}
</code></pre>
<p>super 的用法</p>
<pre><code class="language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">serve_order</span>() {}

<span class="hljs-keyword">mod</span> back_of_house {
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">fix_incorrect_order</span>() {
<span class="hljs-title function_ invoke__">cook_order</span>();
super::<span class="hljs-title function_ invoke__">serve_order</span>();
}

    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cook_order</span>() {}

}
</code></pre>
<p>用 super 表示所在代码块的父级，</p>
<p>也就是 fix_incorrect_order 的父级 mod back_of_house,然后在这个目录下去找到 serve_order 方法</p>
<p>pub struct<br>
pub 放在 struct 前：<br>
struct 是公共的<br>
struct 中的字段默认是私有的</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> back_of_house {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Breakfast</span> {
<span class="hljs-keyword">pub</span> x: <span class="hljs-type">String</span>,<span class="hljs-comment">//公有</span>
y: <span class="hljs-type">String</span>,<span class="hljs-comment">//私有</span>
}
}
</code></pre>
<p>pub enum<br>
pub 放在 enum 前面<br>
enum 是公共的<br>
enum 的变体也都是公共的</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> back_of_house {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Appetizer</span> {
Soup,
Salad,
}
}
</code></pre>
<h3><a id="use-关键字" class="content__heading-anchor"></a>use 关键字</h3>
<p>可以使用 use 关键字将路径导入到作用域内<br>
仍然遵守私有性规则</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {}
}
}

<span class="hljs-keyword">use</span> crate::front_of_house::hosting;<span class="hljs-comment">//绝对路径</span>
<span class="hljs-keyword">use</span> front_of_house::hosting; <span class="hljs-comment">//相对路径</span>

<span class="hljs-comment">//相当于 在这里定义了</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {}
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() {
hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();
hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();
hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();
}
</code></pre>
<p>函数：将函数的父级模块引入作用域是常用做法<br>
下面这种做法可以，但并不是习惯方式。</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {}
}
}

<span class="hljs-keyword">use</span> crate::front_of_house::hosting::add_to_waitlist;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() {
<span class="hljs-title function_ invoke__">add_to_waitlist</span>();
}
<span class="hljs-keyword">struct</span>，<span class="hljs-keyword">enum</span>，其他：指定完整路径（指定到本身）
<span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<span class="hljs-comment">//直接指定到方法</span>
map.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
}
</code></pre>
<p>有一种情况两个不同的类，下面有同名的方法，我们不能指定本身，要加上父级路径</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::fmt;
<span class="hljs-keyword">use</span> std::io;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">f1</span>() <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> {}<span class="hljs-comment">//会报错因为没有返回值</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">f2</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span> {}<span class="hljs-comment">//会报错</span>

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {}
</code></pre>
<h3><a id="as" class="content__heading-anchor"></a>as</h3>
<p>我们有另外一种做法 as</p>
<p>as 关键字可以为引入的路径指定本地的别名</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span>;
<span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">f1</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span> {}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">f2</span>() <span class="hljs-punctuation">-&gt;</span> IoResult {}

<span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() {}
</code></pre>
<p>使用 pub use 重新导出名称</p>
<p>使用 use 将路径（名称）导入到作用域内后，该名称在此作用域内是私有的<br>
可以将条目引入作用域<br>
该条目可以被外部代码引入到它们的作用域</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {}
}
}

<span class="hljs-keyword">use</span> crate::front_of_house::hosting;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() {
hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();
}
</code></pre>
<p>意思就是，use 引入的模块，同一个文件是公有的，但是别的文件访问是私有的，解决这个问题只需要在 use 前面加一个 pub 就可以了</p>
<p>现在 eat_at_restaurant 函数可以在其作用域中调用 hosting::add_to_waitlist，外部代码也可以使用这个路径。</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {}
}
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::front_of_house::hosting;<span class="hljs-comment">//像这样</span>

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() {
hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();
}
</code></pre>
<h3><a id="使用外部包" class="content__heading-anchor"></a>使用外部包</h3>
<p>Cargo.toml 文件添加依赖的包</p>
<pre><code class="language-rust">[dependencies]
rand = <span class="hljs-string">&quot;0.5.5&quot;</span>
</code></pre>
<p>use 将特定条目引入作用域<br>
标准库（std）也被当作外部包，但是不需要修改 dependencies 来包含它</p>
<h3><a id="使用嵌套路径清理大量的-use-语句" class="content__heading-anchor"></a>使用嵌套路径清理大量的 use 语句</h3>
<p>如果使用同一个包或模块下的多个条目<br>
可以使用嵌套路径，在同一行内将上述条目进行引入<br>
路径相同的部分 : : { 路径差异的部分 }</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::cmp::Ordering;
<span class="hljs-keyword">use</span> std::io;
</code></pre>
<p>变为</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::{cmp::Ordering, io};
</code></pre>
<p>特殊情况：</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::io;
<span class="hljs-keyword">use</span> std::io::Write;
</code></pre>
<p>变为</p>
<pre><code class="language-rust"><span class="hljs-keyword">use</span> std::io::{<span class="hljs-keyword">self</span>, Write};
</code></pre>
<h3><a id="通配符" class="content__heading-anchor"></a>通配符</h3>
<p>我么可以使用 * 把路径中所有的公共条目都引入到作用域</p>
<p>把这个路径下的所有都引入了</p>
<p>use std::collections::*;<br>
谨慎使用</p>
<p>应用场景：<br>
测试：将所有被测试代码引入 tests 模块<br>
有时被用于预导入（prelude）模块</p>
<h3><a id="将模块内容移动到其他文件" class="content__heading-anchor"></a>将模块内容移动到其他文件</h3>
<p>模块定义时，如果模块名后边是 &quot; ; &quot; ，而不是代码块<br>
Rust 会从与模块同名的文件中加载内容<br>
模块树的结构不会变化<br>
两层分离<br>
初始内容（ lib.rs 文件 ）</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {}
}
}

<span class="hljs-keyword">use</span> crate::front_of_house::hosting;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() {
hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();
}
</code></pre>
<p>新建 front_of_house.rs 文件</p>
<p>在 lib.rs 文件中</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house;<span class="hljs-comment">//从 front_of_house 文件引入</span>

<span class="hljs-keyword">use</span> crate::front_of_house::hosting;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() {
hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();
}
</code></pre>
<p>在 front_of_house.rs 文件中</p>
<pre><code class="language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting {
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {}
}
</code></pre>
<p>三层分离<br>
如果想把，hosting 里面的内容再次独立出来<br>
新建一个 front_of_house 的文件 ，里面写上 hosting.rs</p>
<p>hosting.rs 内容</p>
<pre><code class="language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() {}
</code></pre>
<p>front_of_house 内容</p>
<pre><code class="language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting;
</code></pre>
<p>lib.rs 内容</p>
<pre><code class="language-rust"><span class="hljs-keyword">mod</span> front_of_house;

<span class="hljs-keyword">use</span> crate::front_of_house::hosting;

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() {
hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();
}
</code></pre>
 </article> </section> </main>  <footer class="footer"> <hr class="footer__divide"> <div class="footer__row"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">9Sky 九天</a> </p> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv>  项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> </footer> </body></html> 