<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>JavaScript探秘：深浅拷贝</title><link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico"><link rel="sitemap" href="/sitemap-index.xml"><title>JavaScript探秘：深浅拷贝</title><link rel="canonical" href="https://wty9sky.github.io/blog/detail/19/"><meta name="description" content="JavaScript探秘系列：在JavaScript编程中，数据的复制是一个基础而又至关重要的概念，尤其在处理复杂的数据结构时，正确地执行拷贝操作可以避免意料之外的数据修改问题。"><meta name="robots" content="index, follow"><meta property="og:title" content="JavaScript探秘：深浅拷贝"><meta property="og:type" content="article"><meta property="og:image" content="/og.svg"><meta property="og:url" content="https://wty9sky.github.io/blog/detail/19/"><meta property="og:locale" content="zh_CN"><meta property="og:locale:alternate" content="zh_TW"><meta property="og:locale:alternate" content="en_US"><meta property="og:site_name" content="9Sky 九天"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/avatar.png"><meta name="generator" content="Astro v4.16.7"><meta name="keywords" content="详情"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.zJyvFudD.css">
<link rel="stylesheet" href="/_astro/about.D3zQv4Ly.css"><script type="module" src="/_astro/hoisted.HO6_Fzad.js"></script></head> <body> <header class="header"> <h5 class="header__heading"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
JavaScript探秘：深浅拷贝 </span> </h5> </header> <div id="navbar-sentinal"></div> <nav class="navbar" id="navbar-wrapper"> <div class="navbar__content"> <h5 class="navbar__path"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
JavaScript探秘：深浅拷贝 </span> </h5> <div class="navbar__menu"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("#navbar-sentinal");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersectin && e[0].boundingClientRect.top <= 0) {
        headerEl.classList.add("navbar--sticked");
      } else {
        headerEl.classList.remove("navbar--sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>  <main class="page"> <section class="page__section page__section--at-top"> <!-- {
        article.cover && (
          <a href={article.cover} data-fancybox data-caption={article.title}>
            <img
              src={article.cover}
              alt={article.title}
              title={article.title}
              class="page__cover mb-8"
            />
          </a>
        )
      } --> <h1 class="page__heading">JavaScript探秘：深浅拷贝</h1> <p class="page__meta"> <i class="ri-calendar-line"></i> <span>2019 年 8 月 23 日 02:25</span> </p> <hr class="page__divide"> <article class="content"> <h2><a id="文章目录" class="content__heading-anchor"></a>文章目录</h2>
<ul>
<li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E4%B8%8E-%E6%B5%85%E6%8B%B7%E8%B4%9D">“深拷贝” 与 “浅拷贝”</a>
<ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">基础概念</a></li>
<li><a href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1">深浅拷贝使用对象</a></li>
<li><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB">浅拷贝和深拷贝的区别</a></li>
<li><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0">浅拷贝的实现</a>
<ul>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D">对象的浅拷贝：</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D">数组的浅拷贝：</a></li>
</ul></li>
<li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%AE%9E%E7%8E%B0">深拷贝的实现</a>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D">数组的深拷贝</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8slice%E5%92%8Cconcat%E6%96%B9%E6%B3%95%E6%9D%A5%E8%A7%A3%E5%86%B3%E4%B8%8A%E9%9D%A2%E7%9A%84%E9%97%AE%E9%A2%98">使用slice()和concat()方法来解决上面的问题</a>
<ul>
<li><a href="#slice">slice()</a></li>
<li><a href="#concat">concat()</a></li>
</ul></li>
<li><a href="#%E5%B1%80%E9%99%90%E6%80%A7">局限性</a>
<ul>
<li><a href="#es6%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D">ES6扩展运算符实现数组的深拷贝</a></li>
</ul></li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D">对象的深拷贝</a>
<ul>
<li><a href="#es6%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D">ES6扩展运算符实现对象的深拷贝</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#jsonstringify%E5%9C%A8%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%AD%E7%9A%84%E5%9D%91">JSON.stringify()在深浅拷贝中的坑</a>
<ul>
<li><a href="#%E5%A4%84%E7%90%86undefinedfunction%E5%92%8Csymbol%E5%80%BC">处理undefined、Function和Symbol值</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E6%95%B0%E5%AD%97%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1">布尔、数字和字符串对象</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5symbol%E9%94%AE%E7%9A%84%E5%B1%9E%E6%80%A7">忽略Symbol键的属性</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%A9%B7%E5%A4%A7infinitynan%E5%92%8Cnull%E5%80%BC">处理无穷大（Infinity）、NaN和Null值</a></li>
<li><a href="#date%E5%AF%B9%E8%B1%A1%E8%A2%AB%E8%A7%86%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">Date对象被视为字符串</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%BC%82%E5%B8%B8">循环引用异常</a>
<ul>
<li><a href="#bigint%E8%BD%AC%E6%8D%A2%E9%94%99%E8%AF%AF">BigInt转换错误</a></li>
</ul></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul></li>
</ul></li>
</ul>
<h1><a id="深拷贝-与-浅拷贝" class="content__heading-anchor"></a>“深拷贝” 与 “浅拷贝”</h1>
<h2><a id="基础概念" class="content__heading-anchor"></a>基础概念</h2>
<p>JavaScript的数据类型</p>
<ul>
<li><p>Javascript有五种基本数据类型和两种引用类型</p></li>
<li><p>基本类型（栈内存）<br>
Undefined，Null，Boolean，Number和String</p></li>
<li><p>引用数据类型（堆内存）</p>
<ul>
<li>Object</li>
<li>Array</li>
</ul></li>
<li><p>Undefined和Null的区别</p>
<ul>
<li>Undefined类型只有一个值，就是undefined，已声明未赋值的变量输出的结果</li>
<li>Null类型也只有一个值，也就是null， 一个不存在的对象的结果</li>
</ul></li>
</ul>
<h2><a id="深浅拷贝使用对象" class="content__heading-anchor"></a>深浅拷贝使用对象</h2>
<ul>
<li>主要针对复杂数据类型（Object，Array）的复制问题。<br>
浅拷贝与深拷贝都可以实现在已有对象上再生出一份的作用。但是对象的实例是存储在堆内存中然后通过一个引用值去操作对象，由此拷贝的时候就存在两种情况了：</li>
</ul>
<h2><a id="浅拷贝和深拷贝的区别" class="content__heading-anchor"></a>浅拷贝和深拷贝的区别</h2>
<ul>
<li>拷贝引用和拷贝实例的区别</li>
<li>浅拷贝（shallow copy）：
<ul>
<li>只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存；</li>
<li>深拷贝（deep copy）：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变。</li>
</ul></li>
</ul>
<h2><a id="浅拷贝的实现" class="content__heading-anchor"></a>浅拷贝的实现</h2>
<p>浅拷贝的意思就是只复制引用，而未复制真正的值，有时候我们只是想备份数组，但是只是简单让它赋给一个变量，改变其中一个，另外一个就紧跟着改变。</p>
<h3><a id="对象的浅拷贝" class="content__heading-anchor"></a>对象的浅拷贝：</h3>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> obj = {
   <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Hanna Ding&#x27;</span>,
   <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>
}
<span class="hljs-keyword">var</span> obj2 = obj;
obj2[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">5</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">//Object {name: &quot;Hanna Ding&quot;, age: 22, c: 5}</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">//Object {name: &quot;Hanna Ding&quot;, age: 22, c: 5}</span>
</code></pre>
<h3><a id="数组的浅拷贝" class="content__heading-anchor"></a>数组的浅拷贝：</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>];

<span class="hljs-keyword">var</span> arr2 = arr;
arr2[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;test&quot;</span>; 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [1, &quot;test&quot;, 3, &quot;4&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">// [1, &quot;test&quot;, 3, &quot;4&quot;]</span>

arr[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;fisrt&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [&quot;fisrt&quot;, &quot;test&quot;, 3, &quot;4&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2); <span class="hljs-comment">// [&quot;fisrt&quot;, &quot;test&quot;, 3, &quot;4&quot;]</span>
</code></pre>
<ul>
<li>利用 = 赋值操作符实现了一个浅拷贝</li>
<li>随着 arr2 和 arr 改变，arr 和 arr2 也随着发生了变化</li>
</ul>
<h2><a id="深拷贝的实现" class="content__heading-anchor"></a>深拷贝的实现</h2>
<h3><a id="数组的深拷贝" class="content__heading-anchor"></a>数组的深拷贝</h3>
<h4><a id="使用slice和concat方法来解决上面的问题" class="content__heading-anchor"></a>使用slice()和concat()方法来解决上面的问题</h4>
<h5><a id="slice" class="content__heading-anchor"></a>slice()</h5>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
<span class="hljs-keyword">var</span> arrCopy = arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);
arrCopy[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;test&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrCopy); <span class="hljs-comment">// [&quot;test&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</code></pre>
<h5><a id="concat" class="content__heading-anchor"></a>concat()</h5>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];
<span class="hljs-keyword">var</span> arrCopy = arr.<span class="hljs-title function_">concat</span>();
arrCopy[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;test&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrCopy); <span class="hljs-comment">// [&quot;test&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</code></pre>
<h4><a id="局限性" class="content__heading-anchor"></a>局限性</h4>
<p>slice() 和 concat()拷贝的局限性</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr1 = [{<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;Roubin&quot;</span>},{<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;RouSe&quot;</span>}];<span class="hljs-comment">//原数组</span>
<span class="hljs-keyword">var</span> arr2 = [].<span class="hljs-title function_">concat</span>(arr1);<span class="hljs-comment">//拷贝数组</span>
arr1[<span class="hljs-number">1</span>].<span class="hljs-property">name</span>=<span class="hljs-string">&quot;Tom&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1);<span class="hljs-comment">//[{&quot;name&quot;:&quot;Roubin&quot;},{&quot;name&quot;:&quot;Tom&quot;}]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<span class="hljs-comment">//[{&quot;name&quot;:&quot;Roubin&quot;},{&quot;name&quot;:&quot;Tom&quot;}]</span>
</code></pre>
<p>结论：使用.concat()和浅拷贝的结果一样<br>
那slice()会出现什么结果</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr1 = [{<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;weifeng&quot;</span>},{<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;boy&quot;</span>}];<span class="hljs-comment">//原数组</span>
<span class="hljs-keyword">var</span> arr2 = arr1.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//拷贝数组</span>
arr1[<span class="hljs-number">1</span>].<span class="hljs-property">name</span>=<span class="hljs-string">&quot;girl&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1);<span class="hljs-comment">// [{&quot;name&quot;:&quot;weifeng&quot;},{&quot;name&quot;:&quot;girl&quot;}]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2);<span class="hljs-comment">//[{&quot;name&quot;:&quot;weifeng&quot;},{&quot;name&quot;:&quot;girl&quot;}</span>
</code></pre>
<p>结论：使用.slice()和浅复制的结果一样</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> a1=[[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>],<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>];
<span class="hljs-keyword">var</span> a2=a1.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>);
a1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>; <span class="hljs-comment">//改变a1第一个元素中的第一个元素</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1);  <span class="hljs-comment">//[[&quot;0&quot;,&quot;2&quot;,&quot;3&quot;],&quot;2&quot;,&quot;3&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2);   <span class="hljs-comment">//[[&quot;0&quot;,&quot;2&quot;,&quot;3&quot;],&quot;2&quot;,&quot;3&quot;]</span>
</code></pre>
<ul>
<li>由于数组的内部属性值是引用对象（Object，Array），slice和concat对对象数组的拷贝，整个拷贝还是浅拷贝，拷贝之后数组各个值的指针还是指向相同的存储地址.</li>
<li>因此，slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝</li>
</ul>
<p>arrayObj.slice(start, [end]) 该方法返回一个 Array 对象，其中包含了 arrayObj 的指定部分。不会改变原数组<br>
arrayObj.concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。<br>
其实也就是下面实现的方式，但还是用上面的方法来实现比较简单高效些</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">arr1, arr2</span>) {
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr1.<span class="hljs-property">length</span>; ++i) {
       arr2[i] = arr1[i];
   }
}
</code></pre>
<h5><a id="es6扩展运算符实现数组的深拷贝" class="content__heading-anchor"></a>ES6扩展运算符实现数组的深拷贝</h5>
<pre><code class="language-js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]
<span class="hljs-keyword">var</span> [ ...arr2 ] = arr
arr[<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)  <span class="hljs-comment">//[1,2,5,4,5]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr2)  <span class="hljs-comment">//[1,2,3,4,5]</span>
</code></pre>
<h4><a id="对象的深拷贝" class="content__heading-anchor"></a>对象的深拷贝</h4>
<ul>
<li><p>对象的深拷贝实现原理： 定义一个新的对象，遍历源对象的属性并赋给新对象的属性</p></li>
<li><p>两种方案：</p>
<ul>
<li>利用递归来实现每一层都重新创建对象并赋值</li>
<li>利用 JSON 对象中的 parse 和 stringify</li>
</ul></li>
</ul>
<h5><a id="es6扩展运算符实现对象的深拷贝" class="content__heading-anchor"></a>ES6扩展运算符实现对象的深拷贝</h5>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;FungLeo&#x27;</span>,
  <span class="hljs-attr">sex</span>: <span class="hljs-string">&#x27;man&#x27;</span>,
  <span class="hljs-attr">old</span>: <span class="hljs-string">&#x27;18&#x27;</span>
}
<span class="hljs-keyword">var</span> { ...obj2 } = obj
obj.<span class="hljs-property">old</span> = <span class="hljs-string">&#x27;22&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj)   <span class="hljs-comment">///{ name: &#x27;FungLeo&#x27;, sex: &#x27;man&#x27;, old: &#x27;22&#x27;}</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2)  <span class="hljs-comment">///{ name: &#x27;FungLeo&#x27;, sex: &#x27;man&#x27;, old: &#x27;18&#x27;}</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {
   <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;xiao ming&#x27;</span>,
   <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>
}

<span class="hljs-keyword">var</span> obj2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
obj2.<span class="hljs-property">name</span> = obj.<span class="hljs-property">name</span>;
obj2.<span class="hljs-property">age</span> = obj.<span class="hljs-property">age</span>

obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;xiaoDing&#x27;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj); <span class="hljs-comment">//Object {name: &quot;xiaoDing&quot;, age: 22}</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">//Object {name: &quot;xiao ming&quot;, age: 22}</span>
</code></pre>
<p>obj2是在堆中开辟的一个新内存块，将obj1的属性赋值给obj2时，obj2是同直接访问对应的内存地址。</p>
<ul>
<li>递归的方法
<ul>
<li>递归的思想就很简单了，就是对每一层的数据都实现一次 创建对象-&gt;对象赋值的操作。</li>
</ul></li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">source</span>){
  <span class="hljs-keyword">const</span> targetObj = source.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span> ? [] : {}; <span class="hljs-comment">// 判断复制的目标是数组还是对象</span>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> keys <span class="hljs-keyword">in</span> source){ <span class="hljs-comment">// 遍历目标</span>
    <span class="hljs-keyword">if</span>(source.<span class="hljs-title function_">hasOwnProperty</span>(keys)){
      <span class="hljs-keyword">if</span>(source[keys] &amp;&amp; <span class="hljs-keyword">typeof</span> source[keys] === <span class="hljs-string">&#x27;object&#x27;</span>){ <span class="hljs-comment">// 如果值是对象，就递归一下</span>
        targetObj[keys] = source[keys].<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Array</span> ? [] : {};
        targetObj[keys] = <span class="hljs-title function_">deepClone</span>(source[keys]);
      }<span class="hljs-keyword">else</span>{ <span class="hljs-comment">// 如果不是，就直接赋值</span>
        targetObj[keys] = source[keys];
      }
    } 
  }
  <span class="hljs-keyword">return</span> targetObj;
}

<span class="hljs-keyword">var</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Hanna&#x27;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>
}
<span class="hljs-keyword">var</span> objCopy = <span class="hljs-title function_">deepClone</span>(obj)
obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ding&#x27;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj);<span class="hljs-comment">//Object {name: &quot;ding&quot;, age: 22}</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objCopy);<span class="hljs-comment">//Object {name: &quot;Hanna&quot;, age: 22}</span>
</code></pre>
<ul>
<li><p>对象与Json相互转换<br>
JSON.stringify/parse的方法</p></li>
<li><p>JSON.stringify()：是将一个 JavaScript 值转成一个 JSON 字符串。</p></li>
</ul>
<ul>
<li>JSON.parse():是将一个 JSON 字符串转成一哥JavaScript 值或对象。<br>
JavaScript 值和 JSON 字符串的相互转换。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">origin</span>){
    <span class="hljs-keyword">var</span> clone={};
    <span class="hljs-keyword">try</span>{
        clone= <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(origin));
    }
    <span class="hljs-keyword">catch</span>(e){
        
    }
    <span class="hljs-keyword">return</span> clone;

}
</code></pre>
<p>未封装和封装的进行比较：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> originArray = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];
<span class="hljs-keyword">const</span> cloneArray = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(originArray));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cloneArray === originArray); <span class="hljs-comment">// false</span>
<span class="hljs-keyword">const</span> originObj = {<span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-attr">c</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-attr">d</span>:{<span class="hljs-attr">dd</span>:<span class="hljs-string">&#x27;dd&#x27;</span>}};
<span class="hljs-keyword">const</span> cloneObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(originObj));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cloneObj === originObj); <span class="hljs-comment">// false</span>
 
cloneObj.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;aa&#x27;</span>;
cloneObj.<span class="hljs-property">c</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>];
cloneObj.<span class="hljs-property">d</span>.<span class="hljs-property">dd</span> = <span class="hljs-string">&#x27;tt&#x27;</span>;
 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cloneObj); 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originObj);
<span class="hljs-comment">/****************封装层**************/</span>
<span class="hljs-keyword">function</span>  <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">origin</span>){
    <span class="hljs-keyword">var</span>  clone={};
    <span class="hljs-keyword">try</span>{
       clone= <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(origin));
    }
    <span class="hljs-keyword">catch</span>(e){
        
    }
    <span class="hljs-keyword">return</span> clone;

}
<span class="hljs-keyword">const</span> originObj = {<span class="hljs-attr">a</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-attr">c</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-attr">d</span>:{<span class="hljs-attr">dd</span>:<span class="hljs-string">&#x27;dd&#x27;</span>}};
<span class="hljs-keyword">const</span> cloneObj = <span class="hljs-title function_">deepClone</span>(originObj);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cloneObj === originObj); <span class="hljs-comment">// false</span>
 <span class="hljs-comment">//改变值</span>
cloneObj.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;aa&#x27;</span>;
cloneObj.<span class="hljs-property">c</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];
cloneObj.<span class="hljs-property">d</span>.<span class="hljs-property">dd</span> = <span class="hljs-string">&#x27;tt&#x27;</span>;

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cloneObj); <span class="hljs-comment">// {a:&#x27;aa&#x27;,b:&#x27;b&#x27;,c:[1,1,1],d:{dd:&#x27;tt&#x27;}};</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(originObj);<span class="hljs-comment">// {a:&#x27;a&#x27;,b:&#x27;b&#x27;,c:[1,2,3],d:{dd:&#x27;dd&#x27;}};</span>
</code></pre>
<ul>
<li>虽然上面的深拷贝很方便（请使用封装函数进行项目开发以便于维护），但是，只适合一些简单的情景（Number, String, Boolean, Array, Object），扁平对象，那些能够被 json 直接表示的数据结构。function对象，RegExp对象是无法通过这种方式深拷贝。</li>
</ul>
<h2><a id="jsonstringify在深浅拷贝中的坑" class="content__heading-anchor"></a>JSON.stringify()在深浅拷贝中的坑</h2>
<h3><a id="处理undefinedfunction和symbol值" class="content__heading-anchor"></a>处理undefined、Function和Symbol值</h3>
<ul>
<li>undefined、Function和Symbol值不是有效的JSON值，用JSON.stringify()转换对象时，如果对象中有以上值时会被省略，或者被更改为null。</li>
</ul>
<p>例如：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj1 = { 
    <span class="hljs-attr">foo</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {}, 
    <span class="hljs-attr">bar</span>: <span class="hljs-literal">undefined</span>, 
    <span class="hljs-attr">baz</span>: <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;example&#x27;</span>) 
};  
<span class="hljs-keyword">const</span> obj2 = {
    <span class="hljs-attr">arr</span>: [<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){}]
};  
<span class="hljs-keyword">const</span> jsonString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1);  
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj1转换后的值为:&#x27;</span>,jsonString); 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;obj2转换后的值为:&#x27;</span>,<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj2)); 
<span class="hljs-comment">// 输出: &#x27;{}&#x27;  </span>
<span class="hljs-comment">// 输出: {&quot;arr&quot;:[null]}</span>
</code></pre>
<h3><a id="布尔数字和字符串对象" class="content__heading-anchor"></a>布尔、数字和字符串对象</h3>
<ul>
<li>布尔、数字和字符串对象在字符串化过程中会被转换为它们对应的原始值。</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> boolObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">true</span>);  
<span class="hljs-keyword">const</span> jsonString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(boolObj);  
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonString); <span class="hljs-comment">// 输出: &#x27;true&#x27;</span>
</code></pre>
<h3><a id="忽略symbol键的属性" class="content__heading-anchor"></a>忽略Symbol键的属性</h3>
<ul>
<li>Symbol键属性在字符串化过程中完全被忽略，即使使用替换函数也是如此。这意味着与Symbol键关联的任何数据都将在生成的JSON字符串中被排除。</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj1 = {
    [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;example&#x27;</span>)]: <span class="hljs-string">&#x27;value&#x27;</span>
};  
<span class="hljs-keyword">const</span> obj2 = {
    [<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;example&#x27;</span>)]: [<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){}]
    };  
<span class="hljs-keyword">const</span> jsonString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1);  
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonString);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj2));
 <span class="hljs-comment">// 均输出: &#x27;{}&#x27;  </span>
</code></pre>
<h3><a id="处理无穷大infinitynan和null值" class="content__heading-anchor"></a>处理无穷大（Infinity）、NaN和Null值</h3>
<ul>
<li>Infinity、NaN 和 null 值在字符串化过程中都被视为 null。</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = { 
    <span class="hljs-attr">value</span>: <span class="hljs-title class_">Infinity</span>, 
    <span class="hljs-attr">error</span>: <span class="hljs-title class_">NaN</span>, 
    <span class="hljs-attr">nothing</span>: <span class="hljs-literal">null</span>
    };  
<span class="hljs-keyword">const</span> jsonString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj);  
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonString); 
<span class="hljs-comment">// 输出: &#x27;{&quot;value&quot;:null,&quot;error&quot;:null,&quot;nothing&quot;:null}&#x27;</span>
</code></pre>
<h3><a id="date对象被视为字符串" class="content__heading-anchor"></a>Date对象被视为字符串</h3>
<ul>
<li>Date实例通过实现toJSON()函数来返回一个字符串（与date.toISOString()相同），因此在字符串化过程中被视为字符串。</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> dateObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
<span class="hljs-keyword">const</span> jsonString = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(dateObj);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonString); 
<span class="hljs-comment">// 输出：&quot;2024-01-31T09:42:00.179Z&quot;</span>
</code></pre>
<h3><a id="循环引用异常" class="content__heading-anchor"></a>循环引用异常</h3>
<p>如果 JSON.stringify() 遇到具有循环引用的对象，它会抛出一个错误。循环引用发生在一个对象在循环中引用自身的情况下。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> circularObj = { <span class="hljs-attr">self</span>: <span class="hljs-literal">null</span> };
circularObj.<span class="hljs-property">self</span> = circularObj;
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(circularObj); 
<span class="hljs-comment">// Uncaught TypeError: Converting circular structure to JSON</span>
</code></pre>
<h4><a id="bigint转换错误" class="content__heading-anchor"></a>BigInt转换错误</h4>
<ul>
<li>使用JSON.stringify（）转换BigInt类型的值时引发错误。</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> bigIntValue = <span class="hljs-title class_">BigInt</span>(<span class="hljs-number">42</span>);  
<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(bigIntValue); <span class="hljs-comment">// Uncaught TypeError: Do not know how to serialize a BigInt</span>
</code></pre>
<h3><a id="总结" class="content__heading-anchor"></a>总结</h3>
<ul>
<li>对象中有时间类型的时候，序列化之后会变成字符串类型。</li>
<li>对象中有undefined和Function类型数据的时候，序列化之后会直接丢失。</li>
<li>对象中有NaN、Infinity和-Infinity的时候，序列化之后会显示null。</li>
<li>对象循环引用的时候，会直接报错。</li>
</ul>
 </article> </section> </main>  <footer class="footer"> <hr class="footer__divide"> <div class="footer__row"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">9Sky 九天</a> </p> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv>  项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> </footer> </body></html> 