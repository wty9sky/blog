<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>Vue3源码解析-Proxy</title><link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico"><link rel="sitemap" href="/sitemap-index.xml"><title>Vue3源码解析-Proxy</title><link rel="canonical" href="https://wty9sky.github.io/blog/detail/8/"><meta name="description" content="Vue3源码解析-Vue3中的proxy"><meta name="robots" content="index, follow"><meta property="og:title" content="Vue3源码解析-Proxy"><meta property="og:type" content="article"><meta property="og:image" content="/og.svg"><meta property="og:url" content="https://wty9sky.github.io/blog/detail/8/"><meta property="og:locale" content="zh_CN"><meta property="og:locale:alternate" content="zh_TW"><meta property="og:locale:alternate" content="en_US"><meta property="og:site_name" content="9Sky 九天"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/avatar.png"><meta name="generator" content="Astro v4.16.7"><meta name="keywords" content="详情"><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.CkC6PiIh.css">
<link rel="stylesheet" href="/_astro/about.D3zQv4Ly.css"><script type="module" src="/_astro/hoisted.HO6_Fzad.js"></script></head> <body> <header class="header"> <h5 class="header__heading"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
Vue3源码解析-Proxy </span> </h5> </header> <div id="navbar-sentinal"></div> <nav class="navbar" id="navbar-wrapper"> <div class="navbar__content"> <h5 class="navbar__path"> <a href="/" class="link">9Sky 九天</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
Vue3源码解析-Proxy </span> </h5> <div class="navbar__menu"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("#navbar-sentinal");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersectin && e[0].boundingClientRect.top <= 0) {
        headerEl.classList.add("navbar--sticked");
      } else {
        headerEl.classList.remove("navbar--sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>  <main class="page"> <section class="page__section page__section--at-top"> <!-- {
        article.cover && (
          <a href={article.cover} data-fancybox data-caption={article.title}>
            <img
              src={article.cover}
              alt={article.title}
              title={article.title}
              class="page__cover mb-8"
            />
          </a>
        )
      } --> <h1 class="page__heading">Vue3源码解析-Proxy</h1> <p class="page__meta"> <i class="ri-calendar-line"></i> <span>2023 年 6 月 9 日 13:12</span> </p> <hr class="page__divide"> <article class="content"> <h2><a id="文章目录" class="content__heading-anchor"></a>文章目录</h2>
<ul>
<li><a href="#vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-proxy">Vue3源码解析-Proxy</a>
<ul>
<li><a href="#vue2-%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">Vue2 中的双向绑定</a></li>
<li><a href="#vue3-%E7%9A%84-proxy">Vue3 的 Proxy</a>
<ul>
<li><a href="#proxy">Proxy</a></li>
<li><a href="#reflect">Reflect</a></li>
</ul></li>
</ul></li>
</ul>
<h1><a id="vue3源码解析-proxy" class="content__heading-anchor"></a>Vue3源码解析-Proxy</h1>
<h2><a id="vue2-中的双向绑定" class="content__heading-anchor"></a>Vue2 中的双向绑定</h2>
<ul>
<li>在 Vue2 中使用的是 Object.defineProperty()</li>
<li>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</li>
<li>defineProperty 只能针对修改对象上的属性</li>
<li>用法：Object.defineProperty(obj, prop, descriptor)
<ul>
<li>obj 要定义属性的对象</li>
<li>prop 要定义或修改的属性的名称或 Symbol</li>
<li>descriptor 要定义或修改的属性描述符</li>
</ul></li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> obj = {};
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, <span class="hljs-string">&quot;a&quot;</span>, {
  <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否可写</span>
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否可配置</span>
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否可枚举</span>
});

<span class="hljs-comment">// 上面给了三个 false, 下面的相关操作就很容易理解了</span>
obj.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// 无效</span>
<span class="hljs-keyword">delete</span> obj.<span class="hljs-property">a</span>; <span class="hljs-comment">// 无效</span>
<span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> obj) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key); <span class="hljs-comment">// 无效</span>
}
</code></pre>
<pre><code class="language-javascript"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, {
<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
<span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveGetter</span> (<span class="hljs-params"></span>) {
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Dep</span>.<span class="hljs-property">target</span>) {
<span class="hljs-comment">// 收集依赖</span>
dep.<span class="hljs-title function_">depend</span>()
}
<span class="hljs-keyword">return</span> value
},
<span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactiveSetter</span> (<span class="hljs-params">newVal</span>) {
<span class="hljs-comment">// ...</span>
<span class="hljs-comment">// 通知视图更新</span>
dep.<span class="hljs-title function_">notify</span>()
}
})
对象的变异
以下的方法为什么不更新

<span class="hljs-title function_">data</span> () {
<span class="hljs-keyword">return</span> {
<span class="hljs-attr">obj</span>: {
<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>
}
}
}

<span class="hljs-attr">methods</span>: {
<span class="hljs-title function_">update</span> () {
<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>
}
}
</code></pre>
<ul>
<li><p>在 created 时</p>
<ul>
<li>我们进行了 data init 方法，会对 data 绑定一个观察者 Observer</li>
<li>data 中的字段更新都会通知依赖收集器 Dep 触发视图更新
<ul>
<li>当我们使用 defineProperty 这个方法只是针对对象的属性进行监听，但是新增属性 b 是在之后添加的，没有相应的 Observer</li>
<li>解决方法
<ul>
<li>vue 全局 set 方法本质就是手动为新增属性添加 Observer 方法</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">target: <span class="hljs-built_in">Array</span>&lt;any&gt; | <span class="hljs-built_in">Object</span>, key: any, val: any</span>): any {
  <span class="hljs-comment">// ....</span>
  <span class="hljs-keyword">if</span> (!ob) {
    target[key] = val;
    <span class="hljs-keyword">return</span> val;
  }
  <span class="hljs-title function_">defineReactive</span>(ob.<span class="hljs-property">value</span>, key, val);
  ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>();
  <span class="hljs-keyword">return</span> val;
}
数组的变异;
<span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">items</span>: [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>],
  },
});
vm.<span class="hljs-property">items</span>[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;4&quot;</span>; <span class="hljs-comment">// 视图并未更新</span>
vm.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> = <span class="hljs-number">6</span>; <span class="hljs-comment">// 视图并未更新</span>
</code></pre>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span>(<span class="hljs-params">data, key, val</span>) {
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(data, key, {
    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">defineGet</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`get key: <span class="hljs-subst">${key}</span> val: <span class="hljs-subst">${val}</span>`</span>);
      <span class="hljs-keyword">return</span> val;
    },
    <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">defineSet</span>(<span class="hljs-params">newVal</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`set key: <span class="hljs-subst">${key}</span> val: <span class="hljs-subst">${newVal}</span>`</span>);
      val = newVal;
    },
  });
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">observe</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) {
    <span class="hljs-title function_">defineReactive</span>(data, key, data[key]);
  });
}

<span class="hljs-keyword">let</span> test = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-title function_">observe</span>(test);

test[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>; <span class="hljs-comment">// set key: 0 val: 4</span>
<span class="hljs-comment">// 以上的例子可以说明这不是 defineProperty 的锅，但是我们打印 test</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test);
</code></pre>
<ul>
<li>基于性能问题不进行监听数组，而且新增索引的确是 defineProperty 做不到的</li>
<li>所以 vue 提供了数组的变异方法</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> methodsToPatch = [
  <span class="hljs-string">&quot;push&quot;</span>,
  <span class="hljs-string">&quot;pop&quot;</span>,
  <span class="hljs-string">&quot;shift&quot;</span>,
  <span class="hljs-string">&quot;unshift&quot;</span>,
  <span class="hljs-string">&quot;splice&quot;</span>,
  <span class="hljs-string">&quot;sort&quot;</span>,
  <span class="hljs-string">&quot;reverse&quot;</span>,
];

methodsToPatch.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) {
  <span class="hljs-comment">// 缓存原生数组</span>
  <span class="hljs-keyword">const</span> original = arrayProto[method];
  <span class="hljs-comment">// def 使用 Object.defineProperty 重新定义属性</span>
  <span class="hljs-title function_">def</span>(arrayMethods, method, <span class="hljs-keyword">function</span> <span class="hljs-title function_">mutator</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">const</span> result = original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args); <span class="hljs-comment">// 调用原生数组的方法</span>

    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>; <span class="hljs-comment">// ob就是observe实例observe才能响应式</span>
    <span class="hljs-keyword">let</span> inserted;
    <span class="hljs-keyword">switch</span> (method) {
      <span class="hljs-comment">// push和unshift方法会增加数组的索引，但是新增的索引位需要手动observe的</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;push&quot;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:
        inserted = args;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-comment">// 同理，splice的第三个参数，为新增的值，也需要手动observe</span>
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:
        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-comment">// 其余的方法都是在原有的索引上更新，初始化的时候已经observe过了</span>
    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted);
    <span class="hljs-comment">// dep通知所有的订阅者触发回调</span>
    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>();
    <span class="hljs-keyword">return</span> result;
  });
});
</code></pre>
<h2><a id="vue3-的-proxy" class="content__heading-anchor"></a>Vue3 的 Proxy</h2>
<p>Vue3 抛弃了数据劫持，使用的是 Proxy+Reflect 来实现的数据代理。</p>
<h3><a id="proxy" class="content__heading-anchor"></a>Proxy</h3>
<p>Proxy:代理，ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>
<p>Proxy 的构造函数语法为：</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);
</code></pre>
<ul>
<li>target：要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li>
<li>handler：一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</li>
</ul>
<p>handle 方法表</p>
<table>
<thead>
<tr><th>方法</th><th>描述</th></tr>
</thead>
<tbody>
<tr><td>handler.has()</td><td>in 操作符的捕捉器。</td></tr>
<tr><td>handler.get()</td><td>属性读取操作的捕捉器。</td></tr>
<tr><td>handler.set()</td><td>属性设置操作的捕捉器。</td></tr>
<tr><td>handler.deleteProperty()</td><td>delete 操作符的捕捉器。</td></tr>
<tr><td>handler.ownKeys()</td><td>Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。</td></tr>
<tr><td>handler.apply()</td><td>函数调用操作的捕捉器。</td></tr>
<tr><td>handler.construct()</td><td>new 操作符的捕捉器</td></tr>
</tbody>
</table>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> originObj = {}
<span class="hljs-keyword">const</span> proxyObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(originObj,{
<span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">target, propKey, receiver</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-number">10</span>
}
});
<span class="hljs-comment">// 代理只会对 proxy 对象生效，如上方的 origin 就没有任何效果</span>
proxyObj.<span class="hljs-property">a</span> <span class="hljs-comment">// 10;</span>
proxyObj.<span class="hljs-property">b</span> <span class="hljs-comment">// 10;</span>
originObj.<span class="hljs-property">a</span> <span class="hljs-comment">// undefined</span>
origin.<span class="hljs-property">b</span> <span class="hljs-comment">// undefined</span>
<span class="hljs-comment">// 使用 has 方法隐藏某些属性，不被 in 运算符发现</span>
<span class="hljs-keyword">var</span> handler = {
<span class="hljs-title function_">has</span> (target, key) {
<span class="hljs-keyword">if</span> (key[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;\_&#x27;</span>) {
<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}
<span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> target;
}
};
<span class="hljs-keyword">var</span> target = { \<span class="hljs-attr">_prop</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;foo&#x27;</span> };
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;\_prop&#x27;</span> <span class="hljs-keyword">in</span> proxy); <span class="hljs-comment">// false</span>
<span class="hljs-comment">// 又比如说 apply 方法拦截函数的调用、call 和 apply 操作。</span>
<span class="hljs-comment">// apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组，</span>
<span class="hljs-keyword">var</span> target = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;I am the target&#x27;</span>; };
<span class="hljs-keyword">var</span> handler = {
<span class="hljs-attr">apply</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;I am the proxy&#x27;</span>;
}
};
<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);
<span class="hljs-title function_">p</span>();
<span class="hljs-comment">// &quot;I am the proxy&quot;</span>
<span class="hljs-comment">// ownKeys 方法可以拦截对象自身属性的读取操作</span>
<span class="hljs-keyword">let</span> target = {
\<span class="hljs-attr">_bar</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,
\<span class="hljs-attr">_prop</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,
<span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;baz&#x27;</span>
};

<span class="hljs-keyword">let</span> handler = {
<span class="hljs-title function_">ownKeys</span> (target) {
<span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> key[<span class="hljs-number">0</span>] !== <span class="hljs-string">&#x27;\_&#x27;</span>);
}
};

<span class="hljs-keyword">let</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(proxy)) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target[key]);
}
</code></pre>
<h3><a id="reflect" class="content__heading-anchor"></a>Reflect</h3>
<p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handlers 的方法相同。<br>
Reflect 不是一个函数对象，因此它是不可构造的。<br>
与大多数全局对象不同 Reflect 并非一个构造函数，所以不能通过 new 运算符对其进行调用，或者将 Reflect 对象作为一个函数来调用。Reflect 的所有属性和方法都是静态的（就像 Math 对象）。<br>
Reflect 对象提供了以下静态方法，这些方法与 proxy handler methods 的命名相同.<br>
语法：<br>
scss 复制代码</p>
<table>
<thead>
<tr><th>语法</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>Reflect.apply(target, thisArgument, argumentsList)</td><td>对一个函数进行调用操作，同时可以传入一个数组作为调用参数<br>和 Function.prototype.apply() 功能类似</td></tr>
<tr><td>Reflect.construct(target, argumentsList[, newTarget])</td><td>对构造函数进行 new 操作，相当于执行 new target(...args)。</td></tr>
<tr><td>Reflect.defineProperty(target, propertyKey, attributes)</td><td>和 Object.defineProperty() 类似。如果设置成功就会返回 true</td></tr>
<tr><td>Reflect.deleteProperty(target, propertyKey)</td><td>作为函数的 delete 操作符，相当于执行 delete target[name]。</td></tr>
<tr><td>Reflect.get(target, propertyKey[, receiver])</td><td>获取对象身上某个属性的值，类似于 target[name]。</td></tr>
<tr><td>Reflect.getOwnPropertyDescriptor(target, propertyKey)</td><td>类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符, 否则返回 undefined。</td></tr>
<tr><td>Reflect.getPrototypeOf(target)</td><td>类似于 Object.getPrototypeOf()。</td></tr>
<tr><td>Reflect.has(target, propertyKey)</td><td>判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。</td></tr>
<tr><td>Reflect.isExtensible(target)</td><td>类似于 Object.isExtensible()。</td></tr>
<tr><td>Reflect.ownKeys(target)</td><td>返回一个包含所有自身属性（不包含继承属性）的数组。<br> (类似于 Object.keys(), 但不会受 enumerable 影响)。</td></tr>
<tr><td>Reflect.preventExtensions(target)</td><td>类似于 Object.preventExtensions()。返回一个 Boolean。</td></tr>
<tr><td>Reflect.set(target, propertyKey, value[, receiver])</td><td>将值分配给属性的函数。返回一个 Boolean，如果更新成功，则返回 true。</td></tr>
<tr><td>Reflect.setPrototypeOf(target, prototype)</td><td>设置对象原型的函数. 返回一个 Boolean， 如果更新成功，则返回 true。</td></tr>
</tbody>
</table>
<p>检测一个对象是否存在特定属性</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> duck = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Maurice&quot;</span>,
  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>,
  <span class="hljs-attr">greeting</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Quaaaack! My name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  },
};

<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(duck, <span class="hljs-string">&quot;color&quot;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(duck, <span class="hljs-string">&quot;haircut&quot;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>为一个对象赋值，获取对象所有的属性</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> duck = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Maurice&quot;</span>,
  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;white&quot;</span>,
  <span class="hljs-attr">greeting</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Quaaaack! My name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>`</span>);
  },
};
<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(duck, <span class="hljs-string">&quot;eyes&quot;</span>, <span class="hljs-string">&quot;black&quot;</span>); <span class="hljs-comment">// returns &quot;true&quot; if successful</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(duck)); <span class="hljs-comment">// [&quot;name&quot;, &quot;color&quot;, &quot;greeting&quot;, &quot;eyes&quot;]</span>
</code></pre>
<p>Vue3 中通过 Proxy 结合 Reflect 来彻底代理实现了数据代理。</p>
 </article> </section> </main>  <footer class="footer"> <hr class="footer__divide"> <div class="footer__row"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">9Sky 九天</a> </p> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  文章 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/projects" data-astro-cid-tfcnbjmv>  项目 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> </footer> </body></html> 